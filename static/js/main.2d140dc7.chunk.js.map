{"version":3,"sources":["../webpack/universalModuleDefinition","lib/util/math/number.ts","lib/util/math/vector.ts","lib/util/math/line.ts","lib/util/math/ray.ts","lib/util/svg-math.ts","lib/graph-components/arc.tsx","lib/graph-components/primitives.tsx","lib/graph-components/asymptotes.tsx","lib/graph-components/axes.tsx","lib/graph-components/endpoint-circles.tsx","lib/graph-components/parametric.tsx","lib/graph-components/plot.tsx","lib/graph-components/exponential.tsx","lib/util/colors.js","lib/graph-components/grid.tsx","lib/util/tex.ts","lib/util/number-strings.ts","lib/graph-components/labels.tsx","lib/graph-components/logarithmic.tsx","lib/graph-components/parabola.tsx","lib/graph-components/piecewise.tsx","lib/graph-components/polar.tsx","lib/graph-components/sinusoid.tsx","lib/graph-components/tick-marks.tsx","lib/graphie-context.tsx","lib/movables/movable-point.tsx","lib/movables/movable-absolute-value.tsx","lib/movables/movable-asymptote.tsx","lib/movables/movable-circle.tsx","lib/movables/movable-exponential.tsx","lib/movables/movable-lines.tsx","lib/movables/movable-logarithmic.tsx","lib/movables/movable-parabola.tsx","lib/movables/movable-sinusoid.tsx","lib/movables/movable-tanget.tsx","demo/index.tsx"],"names":["root","factory","exports","module","define","amd","a","i","this","DEFAULT_TOLERANCE","EPSILON","is","x","toString","call","isNaN","equal","y","tolerance","Math","abs","sign","isInteger","num","round","precision","factor","roundTo","increment","floorTo","floor","ceilTo","ceil","toFraction","decimal","max_denominator","n","d","rem","bound","max","min","factorial","Number","TypeError","product","PRIMES","isPrime","includes","upperLimit","sqrt","getPrimeFactorization","number","maxf","f","subtract","v1","v2","length","map","c","cartFromPolarRad","radius","theta","angle","rad","Array","isArray","undefined","error","cos","sin","normalizeTheta","inDegrees","div","PI","slope","line","getSlopeIntercept","m","snapCoord","coord","snap","val","knumber","scaleVector","point","range","scale","scaleGridUnit","xUnit","yUnit","unscaleVector","scalePoint","unscalePoint","scaleAxisCenter","path","points","closed","arr","scaled","join","parabola","b","evaluateQuadratic","xVertex","xPoint","vertex","control","dx","p","values","concat","sinusoid","quarterPeriod","computeSine","computeDerivative","coordsForOffset","initial","x0","x1","xCoords","yCoords","extent","numQuarterPeriods","distToEdge","coords","Arc","center","startAngle","endAngle","sector","angleInRadians","style","useGraphie","angles","_startAngle","_endAngle","cent","radii","startVector","endVector","startPoint","endPoint","largeAngle","className","Path","Rect","width","height","_x","_y","_width","_height","rectStyle","fill","fillOpacity","Circle","axisCenter","_center","scaledCenter","scaledRadius","circleStyle","stroke","strokeWidth","overflow","cx","cy","r","Ellipse","rx","ry","ellipseStyle","Line","start","end","React","useMemo","y1","x2","y2","Polyline","_points","polylineStyle","Polygon","polygonStyle","Asymptotes","fn","step","asymptotes","lastVal","t","f_t","push","key","asymptotesStyle","strokeDasharray","Axes","axisArrows","axisOpacity","axisCenterX","axisCenterY","axisStyle","opacity","markerEnd","markerStart","axes","id","EndpointCircles","endpointArray","circles","open","Parametric","shade","fn2","xrange","clipper","xy","clippedFn","clippedFn2","paths","lastDiff","lastFlip","top","diff","u","parametricStyles","strokeLinejoin","strokeLinecap","Plot","swapAxes","Error","Exponential","E","h","k","KhanColors","BLUE","ORANGE","PINK","GREEN","PURPLE","RED","GRAY","BLACK","LIGHT_BLUE","LIGHT_ORANGE","LIGHT_PINK","LIGHT_GREEN","LIGHT_PURPLE","LIGHT_RED","LIGHT_GRAY","LIGHT_BLACK","GRAY10","GRAY20","GRAY30","GRAY40","GRAY50","GRAY60","GRAY70","GRAY80","GRAY90","BLUE_A","BLUE_B","BLUE_C","BLUE_D","BLUE_E","TEAL_A","TEAL_B","TEAL_C","TEAL_D","TEAL_E","GREEN_A","GREEN_B","GREEN_C","GREEN_D","GREEN_E","GOLD_A","GOLD_B","GOLD_C","GOLD_D","GOLD_E","RED_A","RED_B","RED_C","RED_D","RED_E","MAROON_A","MAROON_B","MAROON_C","MAROON_D","MAROON_E","PURPLE_A","PURPLE_B","PURPLE_C","PURPLE_D","PURPLE_E","MINT_A","MINT_B","MINT_C","GRAY_A","GRAY_B","GRAY_C","GRAY_D","GRAY_E","GRAY_F","GRAY_G","GRAY_H","GRAY_I","KA_BLUE","KA_GREEN","INTERACTING","INTERACTIVE","DYNAMIC","Grid","gridStep","gridOpacity","isMobile","grid","gridStyle","processMath","text","expr","replace","katex","renderToString","String","Label","direction","latex","tickLen","_text","multipliers","above","right","below","left","fontSize","textAlign","pointerEvents","dangerouslySetInnerHTML","__html","userSelect","Labels","tickStep","labelStep","axisLabels","labelOpacity","unityLabels","xLabelFormat","yLabelFormat","xStep","yStep","xAxisPosition","yAxisPosition","xShowZero","yShowZero","axisOffCenter","showUnityX","showUnityY","startArrow","endArrow","negativeShiftCorrection","labels","l","Logarithmic","log","log10","_range","Parabola","parabolaStyle","Piecewise","fnArray","rangeArray","endpoints","_endpoints","Polar","Sinusoid","_d","_c","sinusoidStyle","TickMarks","tickOpacity","tickStyle","xLen","yLen","ticks","defaultOptions","tickMarks","isDragging","setIsDragging","mouseMove","setMouseMove","Context","createContext","GraphieProvider","rangeShift","domainShift","options","children","cleanedOptions","Object","entries","reduce","acc","prop","match","domainLabel","rangeLabel","gridUnits","useState","onMouseUp","Provider","value","marginLeft","padding","display","xmlns","version","cursor","onMouseMove","e","persist","onMouseLeave","marginTop","graphie","useContext","MovablePoint","setPoint","defaultSnap","ref","useRef","useEffect","current","nativeEvent","offsetX","offsetY","_point","onMouseDown","MovableAbsoluteValue","setVertex","absoluteValueStyle","MovableAsymptote","axis","setAxis","vertical","graphSnap","asymptoteStyle","MovableCircle","setRadius","setCenter","draggableRadius","setDraggableRadius","vector","_draggableRadius","MovableExponential","point1","point2","setPoint1","setPoint2","exp","exponentialStyle","MovableLineSegment","MovableLineRay","ycoord","yrange","Infinity","MovableLine","MovableLogarithmic","_a","_b","_k","logarithmicStyle","MovableParabola","MovableSinusoid","midpoint","maxpoint","setMidpoint","setMaxpoint","MovableTangent","tangentStyle","tan","TestArc","TestAsymptotes","TestCircle","TestEllipse","TestEndpointCircles","TestExponential","TestLine","TestLogarithmic","TestParabola","TestParametric","TestPath","svgMath","TestPiecewise","TestPlot","TestPolar","Î˜","TestPolygon","TestRect","TestSinusoid","TestMovableAbsoluteValue","TestMovablePoint","TestMovableAsymptote","TestMovableCircle","TestMovableExponential","TestMovableLine","TestMovableLineRay","TestMovableLineSegment","TestMovableLogarithmic","TestMovableParabola","TestMovableSinusoid","TestMovableTangent","rootElement","document","getElementById","ReactDOM","shapes","setShapes","movables","setMovables","availableShapes","arc","circle","ellipse","endpointCircles","exponential","logarithmic","parametric","piecewise","plot","polar","polygon","rect","availabeMovables","asymptote","tangent","position","border","keys","name","type","checked","onChange","filter"],"mappings":"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","file":"static/js/main.2d140dc7.chunk.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn ","/*\n * Number Utils\n * A number is a js-number, e.g. 5.12\n */\nexport const DEFAULT_TOLERANCE: number = 1e-9\nexport const EPSILON: number = 2 ** -42\n\nexport const is = (x: any) => {\n  return toString.call(x) === \"[object Number]\" && !isNaN(x)\n}\n\nexport const equal = (x: number, y: number, tolerance = DEFAULT_TOLERANCE) => {\n  // We check === here so that +/-Infinity comparisons work correctly\n  if (x === y) {\n    return true\n  }\n  return Math.abs(x - y) < tolerance\n}\n\nexport const sign = (x: number, tolerance = DEFAULT_TOLERANCE) => {\n  return equal(x, 0, tolerance) ? 0 : Math.abs(x) / x\n}\n\n// Integer in the mathematical sense, so 10.0 is still an integer even though\n// in programming it is not.\nexport const isInteger = (num: number, tolerance = DEFAULT_TOLERANCE) => {\n  return equal(Math.round(num), num, tolerance)\n}\n\n// Round a number to a certain number of decimal places\nexport const round = (num: number, precision: number) => {\n  var factor = 10 ** precision\n  return Math.round(num * factor) / factor\n}\n// Round num to the nearest multiple of increment\n// i.e. roundTo(83, 5) -> 85\nexport const roundTo = (num: number, increment: number) => {\n  return Math.round(num / increment) * increment\n}\n\n// Floors num to the nearest multiple of increment\n// i.e. floorTo(83, 5) -> 80\nexport const floorTo = (num: number, increment: number) => {\n  return Math.floor(num / increment) * increment\n}\n\n// Ceils num to the nearest multiple of increment\n// i.e. ceilTo(81, 5) -> 85\nexport const ceilTo = (num: number, increment: number) => {\n  return Math.ceil(num / increment) * increment\n}\n/**\n * toFraction\n *\n * Returns a [numerator, denominator] array rational representation\n * of `decimal`\n *\n * See http://en.wikipedia.org/wiki/Continued_fraction for implementation\n * details\n *\n * toFraction(4/8) => [1, 2]\n * toFraction(0.66) => [33, 50]\n * toFraction(0.66, 0.01) => [2/3]\n * toFraction(283 + 1/3) => [850, 3]\n */\nexport const toFraction = function(\n  decimal: number,\n  tolerance = EPSILON,\n  max_denominator = 1000\n) {\n  // Initialize everything to compute successive terms of\n  // continued-fraction approximations via recurrence relation\n  let n = [1, 0]\n  let d = [0, 1]\n  let a = Math.floor(decimal)\n  let rem = decimal - a\n\n  while (d[0] <= max_denominator) {\n    if (equal(n[0] / d[0], decimal, tolerance)) {\n      return [n[0], d[0]]\n    }\n    n = [a * n[0] + n[1], n[0]]\n    d = [a * d[0] + d[1], d[0]]\n    a = Math.floor(1 / rem)\n    rem = 1 / rem - a\n  }\n\n  // We failed to find a nice rational representation,\n  // so return an irrational \"fraction\"\n  return [decimal, 1]\n}\n\n// Bound a number by 1e-6 and 1e20 to avoid exponents after toString\nexport const bound = (num: number) => {\n  if (num === 0) {\n    return num\n  } else if (num < 0) {\n    return -bound(-num)\n  } else {\n    return Math.max(1e-6, Math.min(num, 1e20))\n  }\n}\n\n// calculate the factorial of a positive integer\nexport const factorial = (x: number) => {\n  if (x < 0 || !Number.isInteger(x)) {\n    throw TypeError(\"x must be a positive integer\")\n  }\n\n  if (x <= 1) return 1\n\n  let product = x\n\n  while (x > 1) {\n    x -= 1\n    product *= x\n  }\n  return product\n}\n\nconst PRIMES = [\n  2,\n  3,\n  5,\n  7,\n  11,\n  13,\n  17,\n  19,\n  23,\n  29,\n  31,\n  37,\n  41,\n  43,\n  47,\n  53,\n  59,\n  61,\n  67,\n  71,\n  73,\n  79,\n  83,\n  89,\n  97,\n]\n\nexport const isPrime = (n: number): boolean => {\n  if (n <= 1) {\n    return false\n  } else if (n < 101) {\n    return PRIMES.includes(n)\n  } else if (n % 2 === 0) {\n    return false\n  } else if (n % 3 === 0) {\n    return false\n  } else {\n    // sieve of eratosthenes\n    let upperLimit = Math.floor(Math.sqrt(n))\n    for (let i = 5; i <= upperLimit; i += 6) {\n      if (n % i === 0 || n % (i + 2) === 0) return false\n    }\n  }\n\n  return true\n}\n\nexport function getPrimeFactorization(number: number) {\n  if (number === 1) {\n    return []\n  } else if (isPrime(number)) {\n    return [number]\n  }\n\n  const maxf = Math.sqrt(number)\n  for (let f = 2; f <= maxf; f++) {\n    if (number % f === 0) {\n      return [...getPrimeFactorization(f), ...getPrimeFactorization(number / f)]\n    }\n  }\n}\n","/*\n * Vector Utils\n * A vector is an array of numbers e.g. [0, 3, 4].\n */\n\nimport * as knumber from \"./number\"\n\n// like Î£ n\nexport function arraySum(array: number[]) {\n  return array.reduce(function(memo, arg) {\n    return memo + arg\n  }, 0)\n}\n\nexport function is(vec: any, dimension?: number) {\n  if (!Array.isArray(vec)) {\n    return false\n  }\n  if (dimension !== undefined && vec.length !== dimension) {\n    return false\n  }\n  return vec.every(knumber.is)\n}\n\n// Normalize to a unit vector\nexport function normalize(v: number[]) {\n  return scale(v, 1 / length(v))\n}\n\n// Length/magnitude of a vector\nexport function length(v: number[]) {\n  return Math.sqrt(dot(v, v))\n}\n\n// Dot product of multiple vectors\nexport function dot(a: number[], b: number[]) {\n  // vectors must be same length to perform a dot product\n  if (a.length !== b.length) {\n    throw TypeError(\"Vectors must be same dimension to perform dot product\")\n  }\n  var dotted = a.map((c, i) => c * b[i])\n  return arraySum(dotted)\n}\n\n/* vector-add multiple [x, y] coords/vectors\n *\n * add([1, 2], [3, 4]) -> [4, 6]\n */\nexport function add(...vectors: number[][]) {\n  let len = vectors[0].length\n  // create 0 vector of length len\n  let zeroVector = Array.from({ length: len }, () => 0)\n  return vectors.reduce((acc, vec) => {\n    if (vec.length !== len) {\n      throw TypeError(\"vectors must be same dimension to add\")\n    }\n    return acc.map((c, i) => c + vec[i])\n  }, zeroVector)\n}\n\nexport function subtract(v1: number[], v2: number[]) {\n  if (v1.length !== v2.length) {\n    throw TypeError(\"vectors must be same dimension to subtract\")\n  }\n  return v1.map((c, i) => c - v2[i])\n}\n\nexport function negate(v: number[]) {\n  return v.map(c => -c)\n}\n\n// Scale a vector\nexport function scale(v1: number[], scalar: number) {\n  return v1.map(c => c * scalar)\n}\n\nexport function equal(\n  v1: number[],\n  v2: number[],\n  tolerance = knumber.DEFAULT_TOLERANCE\n) {\n  if (v1.length !== v2.length) return false\n  return v1.every((c, i) => knumber.equal(c, v2[i], tolerance))\n}\n\nexport function codirectional(\n  v1: number[],\n  v2: number[],\n  tolerance = knumber.DEFAULT_TOLERANCE\n) {\n  // The origin is trivially codirectional with all other vectors.\n  // This gives nice semantics for codirectionality between points when\n  // comparing their difference vectors.\n  if (\n    knumber.equal(length(v1), 0, tolerance) ||\n    knumber.equal(length(v2), 0, tolerance)\n  ) {\n    return true\n  }\n\n  v1 = normalize(v1)\n  v2 = normalize(v2)\n\n  return equal(v1, v2, tolerance)\n}\n\nexport function collinear(\n  v1: number[],\n  v2: number[],\n  tolerance = knumber.DEFAULT_TOLERANCE\n) {\n  return (\n    codirectional(v1, v2, tolerance) || codirectional(v1, negate(v2), tolerance)\n  )\n}\n\n// Convert a cartesian coordinate into a radian polar coordinate\nexport function polarRadFromCart(v: number[]) {\n  var radius = length(v)\n  var theta = Math.atan2(v[1], v[0])\n\n  // Convert angle range from [-pi, pi] to [0, 2pi]\n  if (theta < 0) {\n    theta += 2 * Math.PI\n  }\n\n  return [radius, theta]\n}\n\n// Converts a cartesian coordinate into a degree polar coordinate\nexport function polarDegFromCart(v: number[]) {\n  var polar = polarRadFromCart(v)\n  return [polar[0], (polar[1] * 180) / Math.PI]\n}\n\n/* Convert a polar coordinate into a cartesian coordinate\n *\n * Examples:\n * cartFromPolarRad(5, Math.PI)\n * cartFromPolarRad([5, Math.PI])\n */\nexport function cartFromPolarRad(radius: number | number[], theta?: number) {\n  let angle: number, rad: number\n  if (Array.isArray(radius)) {\n    angle = radius[1]\n    rad = radius[0]\n  } else if (theta === undefined) {\n    let error = \"theta was not defined. Either supply a second argument to the\"\n    error += \" cartFromPolarRad function or make the first argument an array\"\n    throw TypeError(error)\n  } else {\n    angle = theta\n    rad = radius\n  }\n\n  return [rad * Math.cos(angle), rad * Math.sin(angle)]\n}\n\n/* Convert a polar coordinate into a cartesian coordinate\n *\n * Examples:\n * cartFromPolarDeg(5, 30)\n * cartFromPolarDeg([5, 30])\n */\nexport function cartFromPolarDeg(radius: number | number[], theta?: number) {\n  let angle: number, rad: number\n  if (Array.isArray(radius)) {\n    angle = radius[1]\n    rad = radius[0]\n  } else if (theta === undefined) {\n    let error = \"theta was not defined. Either supply a second argument to the\"\n    error += \" cartFromPolarDeg function or make the first argument an array\"\n    throw TypeError(error)\n  } else {\n    angle = theta\n    rad = radius\n  }\n\n  return cartFromPolarRad(rad, (angle * Math.PI) / 180)\n}\n\n// Rotate vector\nexport function rotateRad(v: number[], theta: number) {\n  var polar = polarRadFromCart(v)\n  var angle = polar[1] + theta\n  return cartFromPolarRad(polar[0], angle)\n}\n\nexport function rotateDeg(v: number[], theta: number) {\n  var polar = polarDegFromCart(v)\n  var angle = polar[1] + theta\n  return cartFromPolarDeg(polar[0], angle)\n}\n\n// Angle between two vectors\nexport function angleRad(v1: number[], v2: number[]) {\n  return Math.acos(dot(v1, v2) / (length(v1) * length(v2)))\n}\n\nexport function angleDeg(v1: number[], v2: number[]) {\n  return (angleRad(v1, v2) * 180) / Math.PI\n}\n\n// Vector projection of v1 onto v2\nexport function projection(v1: number[], v2: number[]) {\n  var scalar = dot(v1, v2) / dot(v2, v2)\n  return scale(v2, scalar)\n}\n\n// Round each number to a certain number of decimal places\nexport function round(vec: number[], precision: number[] | number) {\n  if (Array.isArray(precision)) {\n    if (precision.length !== vec.length) {\n      let error = \"length of precision array must be same as vector you wish to\"\n      error +=\n        \" round. Either change the dimensions of the arrary or just supply a number.\"\n\n      throw TypeError(error)\n    } else {\n      return vec.map((c, i) => knumber.round(c, precision[i]))\n    }\n  } else {\n    return vec.map(c => knumber.round(c, precision))\n  }\n}\n\n// Round each number to the nearest increment\nexport function roundTo(vec: number[], increment: number[] | number) {\n  if (Array.isArray(increment)) {\n    if (increment.length !== vec.length) {\n      throw TypeError(\n        \"dimension of increment vector must same as vec. Either change the dimension or just supply a number.\"\n      )\n    } else {\n      return vec.map((c, i) => knumber.roundTo(c, increment[i]))\n    }\n  } else {\n    return vec.map(c => knumber.roundTo(c, increment))\n  }\n}\n\nexport function floorTo(vec: number[], increment: number[] | number) {\n  if (Array.isArray(increment)) {\n    if (increment.length !== vec.length) {\n      throw TypeError(\n        \"dimension of increment vector must same as vec. Either change the dimension or just supply a number.\"\n      )\n    } else {\n      return vec.map((c, i) => knumber.floorTo(c, increment[i]))\n    }\n  } else {\n    return vec.map(c => knumber.floorTo(c, increment))\n  }\n}\n\nexport function ceilTo(vec: number[], increment: number[] | number) {\n  if (Array.isArray(increment)) {\n    if (increment.length !== vec.length) {\n      throw TypeError(\n        \"dimension of increment vector must same as vec. Either change the dimension or just supply a number.\"\n      )\n    } else {\n      return vec.map((c, i) => knumber.ceilTo(c, increment[i]))\n    }\n  } else {\n    return vec.map(c => knumber.ceilTo(c, increment))\n  }\n}\n\n// given an angle, return the number of revolutions and the remainder angle\nexport const normalizeTheta = (theta: number, inDegrees = false) => {\n  let div = inDegrees ? 360 : 2 * Math.PI\n\n  // [n, deg]\n  return [~~(theta / div), ((theta % div) + div) % div]\n}\n\nexport default {\n  ceilTo,\n  floorTo,\n  roundTo,\n  round,\n  projection,\n  angleDeg,\n  angleRad,\n  rotateDeg,\n  rotateRad,\n  cartFromPolarDeg,\n  cartFromPolarRad,\n  polarDegFromCart,\n  polarRadFromCart,\n  collinear,\n  codirectional,\n  equal,\n  scale,\n  negate,\n  subtract,\n  add,\n  dot,\n  length,\n  normalize,\n  is,\n  arraySum,\n  normalizeTheta,\n}\n","/*\n * Line Utils\n * A line can be described with an array of two points e.g. [[-5, 0], [5, 0]].\n */\n\nimport kpoint from \"./point\"\nimport * as kvector from \"./vector\"\nimport { DEFAULT_TOLERANCE, toFraction } from \"./number\"\n\nexport function distanceToPoint(line: number[][], point: number[]) {\n  return kpoint.distanceToLine(point, line)\n}\n\nexport function reflectPoint(line: number[][], point: number[]) {\n  return kpoint.reflectOverLine(point, line)\n}\n\nexport function midpoint(line: number[][]) {\n  return [(line[0][0] + line[1][0]) / 2, (line[0][1] + line[1][1]) / 2]\n}\n\nexport function slope(line: number[][]) {\n  return (line[1][1] - line[0][1]) / (line[1][0] - line[0][0])\n}\n\nexport function intercepts(line: number[][]) {\n  let m = slope(line)\n  // b = y - mx\n  let yIntercept = line[1][1] - m * line[1][0]\n  // x = -b/m\n  let xIntercept = -yIntercept / m\n  return [xIntercept, yIntercept]\n}\n\n// return coefficients m and b for y = mx + b\nexport function getSlopeIntercept(line: number[][]) {\n  let m = (line[1][1] - line[0][1]) / (line[1][0] - line[0][0])\n  let b = line[1][1] - m * line[1][0]\n  return [m, b]\n}\n\n// returns coefficients A, B, and C for Ax + By = C, with constraints that A > 0,\n// and A, B, and C are integers.\nexport function getStandardLine(line: number[][]) {\n  let [m, b] = getSlopeIntercept(line)\n  let _A = toFraction(-m)\n  let _C = toFraction(b)\n\n  // find lcm of _A and _C\n  let mod, gcd, lcm\n  let a = Math.abs(_A[1])\n  let c = Math.abs(_C[1])\n\n  while (c) {\n    mod = a % c\n    a = c\n    c = mod\n  }\n\n  gcd = a\n  lcm = Math.abs(_A[1] * _C[1]) / gcd\n\n  return m > 0\n    ? [(-_A[0] * lcm) / _A[1], -lcm, -(_C[0] * lcm) / _C[1]]\n    : [(_A[0] * lcm) / _A[1], lcm, (_C[0] * lcm) / _C[1]]\n}\n\nexport function equal(\n  line1: number[][],\n  line2: number[][],\n  tolerance = DEFAULT_TOLERANCE\n) {\n  // TODO: A nicer implementation might just check collinearity of\n  // vectors using underscore magick\n  // Compare the directions of the lines\n  var v1 = kvector.subtract(line1[1], line1[0])\n  var v2 = kvector.subtract(line2[1], line2[0])\n  if (!kvector.collinear(v1, v2, tolerance)) {\n    return false\n  }\n  // If the start point is the same for the two lines, then they are the same\n  if (kpoint.equal(line1[0], line2[0])) {\n    return true\n  }\n  // Make sure that the direction to get from line1 to\n  // line2 is the same as the direction of the lines\n  var line1ToLine2Vector = kvector.subtract(line2[0], line1[0])\n  return kvector.collinear(v1, line1ToLine2Vector, tolerance)\n}\n\nexport default {\n  equal,\n  midpoint,\n  slope,\n  intercepts,\n  reflectPoint,\n  distanceToPoint,\n  getSlopeIntercept,\n  getStandardLine,\n}\n","/*\n * Ray Utils\n * A ray is an array of an endpoint and another point along the ray.\n * For example, [[0, 0], [1, 0]] is the ray starting at the origin and\n * traveling along the positive x-axis.\n */\n\nimport * as kvector from \"./vector\"\nimport kpoint from \"./point\"\nimport { DEFAULT_TOLERANCE } from \"./number\"\n\nfunction equal(\n  ray1: number[][],\n  ray2: number[][],\n  tolerance = DEFAULT_TOLERANCE\n) {\n  // Compare the directions of the rays\n  var v1 = kvector.subtract(ray1[1], ray1[0])\n  var v2 = kvector.subtract(ray2[1], ray2[0])\n\n  var sameOrigin = kpoint.equal(ray1[0], ray2[0])\n  var codirectional = kvector.codirectional(v1, v2, tolerance)\n\n  return sameOrigin && codirectional\n}\n\nexport default { equal }\n","import { number as knumber } from \"./math\"\n\nexport const snapCoord = (coord: number[], snap: number[]) =>\n  coord.map((val, i) => knumber.roundTo(val, snap[i]))\n\n// given a vector as [x,y] in graph units, scales to the svg units\nexport const scaleVector = (\n  point: number | number[],\n  range: number[][],\n  scale: number[]\n) => {\n  if (typeof point === \"number\") {\n    return scaleVector([point, point], range, scale)\n  }\n\n  const [xUnit, yUnit] = scaleGridUnit(range, scale)\n  return [xUnit * point[0], yUnit * point[1]]\n}\n// given a vector [x,y] svg units, scales back down to a vector in graph units\nexport const unscaleVector = (point: number | number[], scale: number[]) => {\n  if (typeof point === \"number\") {\n    return unscaleVector([point, point], scale)\n  }\n\n  return [point[0] / scale[0], point[1] / scale[1]]\n}\n\n// given a point in graph units, return point in svg units\nexport const scalePoint = (\n  point: number[] | number,\n  range: number[][],\n  scale: number[]\n) => {\n  if (typeof point === \"number\") {\n    return scalePoint([point, point], range, scale)\n  }\n\n  const x = point[0] - range[0][0]\n  const y = range[1][1] - point[1]\n  const xUnit = scale[0] / (range[0][1] - range[0][0])\n  const yUnit = scale[1] / (range[1][1] - range[1][0])\n\n  return [x * xUnit, y * yUnit]\n}\n\n// given a point in svg units return point in graph units\nexport const unscalePoint = (\n  point: number | number[],\n  range: number[][],\n  scale: number[]\n) => {\n  if (typeof point === \"number\") {\n    return unscalePoint([point, point], range, scale)\n  }\n\n  const [xUnit, yUnit] = scaleGridUnit(range, scale)\n  const x = point[0]\n  const y = point[1]\n  return [x / xUnit + range[0][0], range[1][1] - y / yUnit]\n}\n\n// given a gridRange in grid units return the number of svg pixels to make 1 unit\nexport const scaleGridUnit = (range: number[][], scale: number[]) => {\n  const xUnit = scale[0] / (range[0][1] - range[0][0])\n  const yUnit = scale[1] / (range[1][1] - range[1][0])\n  return [xUnit, yUnit]\n}\n\nexport const scaleAxisCenter = (\n  point: number | number[],\n  range: number[][],\n  scale: number[]\n) => {\n  if (typeof point === \"number\") {\n    return scaleAxisCenter([point, point], range, scale)\n  }\n\n  const xUnit = scale[0] / (range[0][1] - range[0][0])\n  const yUnit = scale[1] / (range[1][1] - range[1][0])\n\n  // scale center from units to pixels\n  const axisCenterX =\n    point[0] === 0 ? scale[0] / 2 : scale[0] / 2 + (scale[0] / point[0]) * xUnit\n  const axisCenterY =\n    point[1] === 0 ? scale[1] / 2 : scale[1] / 2 + (scale[1] / point[1]) * yUnit\n\n  return [axisCenterX, axisCenterY]\n}\n\nexport const path = function(\n  points: number[][],\n  range: number[][],\n  scale: number[],\n  closed: boolean = false\n) {\n  return points\n    .map((point, i, arr) => {\n      let scaled = scalePoint(point, range, scale)\n\n      return `${i === 0 ? \"M\" : \"L\"}${knumber.bound(scaled[0])} ${knumber.bound(\n        scaled[1]\n      )}${arr.length - 1 === i && closed ? \"z\" : \"\"}`\n    })\n    .join(\"\")\n}\n\nexport const parabola = (\n  a: number,\n  b: number,\n  c: number,\n  range: number[][],\n  scale: number[]\n) => {\n  const evaluateQuadratic = (x: number) => (a * x + b) * x + c\n\n  // If points are collinear, plot a line instead\n  if (a === 0) {\n    const points = range[0].map(x => [x, evaluateQuadratic(x)])\n    return path(points, range, scale)\n  }\n\n  // Calculate x coordinates of points on parabola\n  const xVertex = -b / (2 * a)\n  const distToEdge = Math.max(\n    Math.abs(xVertex - range[0][0]),\n    Math.abs(xVertex - range[0][1])\n  )\n\n  // To guarantee that drawn parabola to spans the viewport, use a point\n  // on the edge of the graph furtherest from the vertex\n  const xPoint = xVertex + distToEdge\n\n  // Compute parabola and other point on the curve\n  const vertex = [xVertex, evaluateQuadratic(xVertex)]\n  const point = [xPoint, evaluateQuadratic(xPoint)]\n\n  // Calculate SVG 'control' point, defined by spec\n  const control = [vertex[0], vertex[1] - (point[1] - vertex[1])]\n\n  // Calculate mirror points across parabola's axis of symmetry\n  const dx = Math.abs(vertex[0] - point[0])\n  const left = [vertex[0] - dx, point[1]]\n  const right = [vertex[0] + dx, point[1]]\n\n  // Scale and bound\n  const points = [left, control, right].map(p => scalePoint(p, range, scale))\n  const values = [].concat(...points).map(knumber.bound)\n  return `M${values[0]},${values[1]} Q${values[2]},${values[3]} ${values[4]},${values[5]}`\n}\n\nexport const sinusoid = (\n  a: number,\n  b: number,\n  c: number,\n  d: number,\n  range: number[][],\n  scale: number[]\n) => {\n  // Plot a sinusoid of the form: f(x) = a * sin(b * x - c) + d\n  const quarterPeriod = Math.abs(Math.PI / (2 * b))\n\n  const computeSine = (x: number) => a * Math.sin(b * x - c) + d\n\n  const computeDerivative = (x: number) => a * b * Math.cos(c - b * x)\n\n  const coordsForOffset = (initial: number, i: number) => {\n    // Return the cubic coordinates (including the two anchor and two\n    // control points) for the ith portion of the sinusoid.\n    const x0 = initial + quarterPeriod * i\n    const x1 = x0 + quarterPeriod\n\n    // Interpolate using derivative technique\n    // See: http://stackoverflow.com/questions/13932704/how-to-draw-sine-waves-with-svg-js\n    const xCoords = [\n      x0,\n      (x0 * 2) / 3 + (x1 * 1) / 3,\n      (x0 * 1) / 3 + (x1 * 2) / 3,\n      x1,\n    ]\n    const yCoords = [\n      computeSine(x0),\n      computeSine(x0) + (computeDerivative(x0) * (x1 - x0)) / 3,\n      computeSine(x1) - (computeDerivative(x1) * (x1 - x0)) / 3,\n      computeSine(x1),\n    ]\n\n    // Zip and scale\n    const zippedCoords = xCoords.map((coord, i) => [coord, yCoords[i]])\n    return zippedCoords.map(coord => scalePoint(coord, range, scale))\n  }\n\n  // How many quarter-periods do we need to span the graph?\n  const extent = range[0][1] - range[0][0]\n  const numQuarterPeriods = Math.ceil(extent / quarterPeriod) + 1\n\n  // Find starting coordinate: first anchor point curve left of xRange[0]\n  let initial = c / b\n  const distToEdge = initial - range[0][0]\n  initial -= quarterPeriod * Math.ceil(distToEdge / quarterPeriod)\n\n  // First portion of path is special-case, requiring move-to ('M')\n  let coords = coordsForOffset(initial, 0)\n  let path = `M${coords[0][0]},${coords[0][1]} C${coords[1][0]},${coords[1][1]} ${coords[2][0]},${coords[2][1]} ${coords[3][0]},${coords[3][1]}`\n\n  for (let i = 1; i < numQuarterPeriods; i++) {\n    coords = coordsForOffset(initial, i)\n    path += ` C${coords[1][0]},${coords[1][1]} ${coords[2][0]},${coords[2][1]} ${coords[3][0]},${coords[3][1]}`\n  }\n\n  return path\n}\n","import * as React from \"react\"\nimport { useGraphie } from \"../graphie-context\"\nimport { normalizeTheta, cartFromPolarRad } from \"../util/math/vector\"\nimport { scalePoint, scaleVector } from \"../util/svg-math\"\n\ntype propTypes = {\n  center: number[]\n  radius: number\n  startAngle: number\n  endAngle: number\n  sector: boolean\n  angleInRadians?: boolean\n  style?: {}\n}\nexport const Arc = ({\n  center,\n  radius,\n  startAngle,\n  endAngle,\n  sector,\n  angleInRadians = true,\n  style,\n}: propTypes) => {\n  const { range, scale } = useGraphie()\n\n  let angles = angleInRadians\n    ? [startAngle, endAngle]\n    : [(startAngle * Math.PI) / 180, (endAngle * Math.PI) / 180]\n  // let _startAngle = ((startAngle % 360) + 360) % 360\n  // let _endAngle = ((endAngle % 360) + 360) % 360\n  let _startAngle = normalizeTheta(angles[0])[1]\n  let _endAngle = normalizeTheta(angles[1])[1]\n\n  const cent = scalePoint(center, range, scale)\n  const radii = scaleVector(radius, range, scale)\n  const startVector = cartFromPolarRad(radius, _startAngle)\n  const endVector = cartFromPolarRad(radius, _endAngle)\n\n  const startPoint = scalePoint(\n    [center[0] + startVector[0], center[1] + startVector[1]],\n    range,\n    scale\n  )\n  const endPoint = scalePoint(\n    [center[0] + endVector[0], center[1] + endVector[1]],\n    range,\n    scale\n  )\n\n  const largeAngle = normalizeTheta(_endAngle - _startAngle)[1] > Math.PI\n\n  const path = `M${startPoint.join()}A${radii.join()} 0 ${\n    largeAngle ? 1 : 0\n  } 0 ${endPoint.join()}${sector ? \"L\" + cent.join(\" \") + \"z\" : \"\"}`\n\n  return <path className=\"graphie-arc\" d={path} style={style} />\n}\n","/* The functions in this file should render the primitive svg elements:\n * path, rect, circle, ellipse, line, polyline, and polygon. All other graphie\n * elements should just consume one of these primatives\n */\nimport React from \"react\"\nimport { useGraphie } from \"../graphie-context\"\nimport { scalePoint, scaleVector } from \"../util/svg-math\"\n\n// I only include path for consistency. I know it could be used without an extra\n// React wrapper.\ntype pathProps = {\n  d: string\n  style?: {}\n}\nexport const Path = ({ d, style }: pathProps) => <path d={d} style={style} />\n\ntype rectPropTypes = {\n  x: number\n  y: number\n  width: number\n  height: number\n  style?: {}\n}\n// (x, y) is coordinate of upper left corner\nexport const Rect = ({ x, y, width, height, style }: rectPropTypes) => {\n  const { range, scale } = useGraphie()\n  const [_x, _y] = scalePoint([x, y], range, scale)\n  const [_width, _height] = scaleVector([width, height], range, scale)\n\n  let rectStyle = {\n    fill: \"#000\",\n    fillOpacity: 0.1,\n    ...style,\n  }\n  return (\n    <rect x={_x} y={_y} width={_width} height={_height} style={rectStyle} />\n  )\n}\n\ntype circleProps = {\n  center: number[]\n  radius: number\n  style?: {}\n}\nexport const Circle = ({ center, radius, style }: circleProps) => {\n  const { range, scale, axisCenter } = useGraphie()\n\n  let _center = center.map((c, i) => c + axisCenter[i])\n  let scaledCenter = scalePoint(_center, range, scale)\n  let scaledRadius = (radius * scale[0]) / (range[0][1] - range[0][0])\n\n  let circleStyle = {\n    fill: \"none\",\n    stroke: \"black\",\n    strokeWidth: 3,\n    overflow: \"hidden\",\n    ...style,\n  }\n  return (\n    <circle\n      cx={scaledCenter[0]}\n      cy={scaledCenter[1]}\n      r={scaledRadius}\n      style={circleStyle}\n    />\n  )\n}\n\ntype ellipsePropType = {\n  center: number[]\n  radii: number[]\n  style?: {}\n}\nexport const Ellipse = ({ center, radii, style }: ellipsePropType) => {\n  const { range, scale } = useGraphie()\n  const [cx, cy] = scalePoint(center, range, scale)\n  const [rx, ry] = scaleVector(radii, range, scale)\n\n  const ellipseStyle = {\n    fill: \"#000\",\n    fillOpacity: 0.1,\n    ...style,\n  }\n  return <ellipse cx={cx} cy={cy} rx={rx} ry={ry} style={ellipseStyle} />\n}\n\ntype lineProps = { start: number[]; end: number[]; style?: {} }\nexport const Line = ({ start, end, style }: lineProps) => {\n  const { range, scale } = useGraphie()\n  const [x1, y1] = React.useMemo(() => scalePoint(start, range, scale), [\n    start,\n    range,\n    scale,\n  ])\n  const [x2, y2] = React.useMemo(() => scalePoint(end, range, scale), [\n    end,\n    range,\n    scale,\n  ])\n  return <line x1={x1} x2={x2} y1={y1} y2={y2} style={style} />\n}\n\ntype polylineProps = {\n  points: number[][]\n  style?: {}\n}\nexport const Polyline = ({ points, style }: polylineProps) => {\n  const { range, scale } = useGraphie()\n  const _points = points.map(p => scalePoint(p, range, scale).join())\n\n  let polylineStyle = {\n    fill: \"none\",\n    ...style,\n  }\n\n  return <polyline points={_points.join(\" \")} style={polylineStyle} />\n}\n\ntype polygonProps = {\n  points: number[][]\n  style?: {}\n}\nexport const Polygon = ({ points, style }: polygonProps) => {\n  const { range, scale } = useGraphie()\n  const _points = points.map(p => scalePoint(p, range, scale).join())\n\n  let polygonStyle = {\n    fill: \"#000\",\n    fillOpacity: 0.1,\n    ...style,\n  }\n\n  return <polygon points={_points.join(\" \")} style={polygonStyle} />\n}\n","import * as React from \"react\"\nimport { scaleGridUnit } from \"../util/svg-math\"\nimport { useGraphie } from \"../graphie-context\"\nimport { Line } from \"./primitives\"\n\ntype propTypes = {\n  fn: (x: number) => number\n  style?: {}\n}\n// find and plot the asymptotes of the supplied function. You would usually\n// use this in conjunction with another component like Plot or Parametric\nexport const Asymptotes = ({ fn, style }: propTypes) => {\n  const { range, scale } = useGraphie()\n  const min = range[0][0]\n  const max = range[0][1]\n  const step = (max - min) / (2 * scale[0])\n\n  const asymptotes = []\n  let lastVal = fn(min)\n\n  for (let t = min; t <= max; t += step) {\n    const f_t = fn(t)\n    // since step size is so small, we can find the value that flips the output,\n    // and present it as the asymptote\n    if (\n      /* eslint-disable no-mixed-operators */\n      f_t < 0 !== lastVal < 0 && // fn(t) has switched signs\n      Math.abs(f_t - lastVal) > 2 * scale[1] // i.e. is approaching infinity\n      /* eslint-enable no-mixed-operators */\n    ) {\n      // and plot a line there\n      asymptotes.push(\n        <Line\n          key={`asymptote-${t}`}\n          start={[t, range[1][0]]}\n          end={[t, range[1][1]]}\n        />\n      )\n    }\n\n    lastVal = f_t\n  }\n\n  const [, yUnit] = scaleGridUnit(range, scale)\n  const asymptotesStyle: any = {\n    strokeDasharray: 0.25 * yUnit,\n    ...style,\n  }\n  return <g style={asymptotesStyle}>{asymptotes}</g>\n}\n","import React from \"react\"\n\nimport { useGraphie } from \"../graphie-context\"\nimport { Line } from \"./primitives\"\n\ntype axesProps = {\n  style?: {}\n}\nexport const Axes = ({ style }: axesProps) => {\n  const {\n    range, // x, y ranges of graph, in graph units\n    axisArrows, // string representation of arrows \"<->\", \"->\", \"<-\",\n    axisOpacity,\n    axisCenter, // displacemnt of center point, in graph units\n  } = useGraphie()\n\n  const [axisCenterX, axisCenterY] = axisCenter\n\n  let axisStyle: {\n    markerEnd?: string\n    markerStart?: string\n    stroke: string\n    opacity?: number\n    strokeWidth: number\n  } = {\n    stroke: \"#000000\",\n    opacity: axisOpacity,\n    strokeWidth: 2,\n    ...style,\n  }\n\n  if (axisArrows === \"<->\" || axisArrows === true) {\n    axisStyle.markerEnd = 'URL(\"#open-endpoint\")'\n    axisStyle.markerStart = 'URL(\"#open-endpoint\")'\n  } else if (axisArrows === \"->\") {\n    axisStyle.markerEnd = 'URL(\"#axis-arrowhead\")'\n  } else if (axisArrows === \"<-\") {\n    axisStyle.markerStart = 'URL(\"#axis-arrowhead\")'\n  }\n\n  const axes = []\n  axes.push(\n    <Line\n      key=\"x-axis\"\n      start={[range[0][0], axisCenterY]}\n      end={[range[0][1], axisCenterY]}\n      style={axisStyle}\n    />\n  )\n  axes.push(\n    <Line\n      key=\"y-axis\"\n      start={[axisCenterX, range[1][0]]}\n      end={[axisCenterX, range[1][1]]}\n      style={axisStyle}\n    />\n  )\n\n  return <g id=\"graphie-axes\">{axes}</g>\n}\n","import React from \"react\"\nimport { Circle } from \"./primitives\"\n\ntype propTypes = {\n  endpointArray: { point: number[]; open: boolean }[]\n  style?: { [key: string]: any }\n}\nexport const EndpointCircles = ({ endpointArray, style }: propTypes) => {\n  const circles = endpointArray.map((coord, i) => {\n    let circleStyle = {\n      ...style,\n      stroke: !coord.open ? \"none\" : style?.stroke,\n      fill: coord.open ? \"#fff\" : style?.fill,\n    }\n    return (\n      <Circle\n        key={`endpoint-circle-${i}`}\n        center={coord.point}\n        radius={0.25}\n        style={circleStyle}\n      />\n    )\n  })\n\n  return <g>{circles}</g>\n}\n","import * as React from \"react\"\nimport { subtract } from \"../util/math/vector\"\nimport { useGraphie } from \"../graphie-context\"\nimport { Polyline } from \"./primitives\"\n\ntype propTypes = {\n  fn: (x: number) => number[]\n  shade?: boolean\n  range?: number[]\n  fn2?: (t: number) => number[]\n  style?: {}\n}\nexport const Parametric = ({\n  fn,\n  shade = false,\n  range,\n  fn2 = t => [t, 0],\n  style,\n}: propTypes) => {\n  const {\n    range: [xrange],\n    scale,\n  } = useGraphie()\n\n  // Note: fn2 should only be set if 'shade' is true, as it denotes\n  // the function between which fn should have its area shaded.\n  // In general, plotParametric shouldn't be used to shade the area\n  // between two arbitrary parametrics functions over an interval,\n  // as the method assumes that fn and fn2 are both of the form\n  // fn(t) = (t, fn'(t)) for some initial fn'.\n\n  // We truncate to 500,000, since anything bigger causes\n  // overflow in the firefox svg renderer.  This is safe\n  // since 500,000 is outside the viewport anyway.  We\n  // write these functions the way we do to handle undefined.\n  const clipper = (xy: number[]) => {\n    if (Math.abs(xy[1]) > 500000) {\n      return [xy[0], Math.min(Math.max(xy[1], -500000), 500000)]\n    }\n    return xy\n  }\n  const clippedFn = (x: number) => clipper(fn(x))\n  const clippedFn2 = (x: number) => clipper(fn2(x))\n\n  const min = range ? range[0] : xrange[0]\n  const max = range ? range[1] : xrange[1]\n\n  let step = (max - min) / (2 * scale[0])\n  if (step === 0) {\n    step = 1\n  }\n\n  let paths = []\n  let points = []\n  let lastDiff = subtract(clippedFn(min), clippedFn2(min))\n\n  let lastFlip = min\n  for (let t = min; t <= max; t += step) {\n    const top = clippedFn(t)\n    const bottom = clippedFn2(t)\n    const diff = subtract(top, bottom)\n\n    // Find points where it flips\n    // Create path that sketches area between the two functions\n    if (\n      // if there is an asymptote here, meaning that the graph\n      // switches signs and has a large difference\n      /* eslint-disable no-mixed-operators */\n      (diff[1] < 0 !== lastDiff[1] < 0 &&\n        Math.abs(diff[1] - lastDiff[1]) > 2 * scale[1]) ||\n      /* eslint-enable no-mixed-operators */\n      // or the function is undefined\n      isNaN(diff[1])\n    ) {\n      // split the path at this point, and draw it\n      if (shade) {\n        points.push(top)\n\n        // backtrack to draw paired function\n        for (let u = t - step; u >= lastFlip; u -= step) {\n          points.push(clippedFn2(u))\n        }\n        lastFlip = t\n      }\n      paths.push(\n        <Polyline\n          key={`parametric-path-${t}`}\n          style={{ fill: shade ? \"inherit\" : \"none\" }}\n          points={points}\n        />\n      )\n      // restart the path, excluding this point\n      points = []\n      if (shade) {\n        points.push(top)\n      }\n    } else {\n      // otherwise, just add the point to the path\n      points.push(top)\n    }\n\n    lastDiff = diff\n  }\n\n  if (shade) {\n    // backtrack to draw paired function\n    for (let u = max - step; u >= lastFlip; u -= step) {\n      points.push(clippedFn2(u))\n    }\n  }\n  paths.push(\n    <Polyline\n      key=\"parametric-path\"\n      style={{ fill: shade ? \"inherit\" : \"none\" }}\n      points={points}\n    />\n  )\n\n  let parametricStyles: any = {\n    strokeLinejoin: \"round\",\n    strokeLinecap: \"round\",\n    fill: shade ? \"#000\" : \"none\",\n    fillOpacity: 0.5,\n    ...style,\n  }\n\n  return <g style={parametricStyles}>{paths}</g>\n}\n","import React from \"react\"\nimport { Parametric } from \"./parametric\"\n\ntype propTypes = {\n  fn: (t: number) => number\n  range: number[]\n  swapAxes: boolean\n  shade: boolean\n  fn2?: (t: number) => number\n  style?: {}\n}\nexport const Plot = ({ fn, range, swapAxes, shade, fn2, style }: propTypes) => {\n  if (swapAxes) {\n    if (fn2) {\n      // TODO: support swapped axis area shading\n      throw new Error(\"Can't shade area between functions with swapped axes.\")\n    }\n    return (\n      <Parametric\n        fn={y => [fn(y), y]}\n        range={range}\n        shade={shade}\n        style={style}\n      />\n    )\n  } else {\n    if (fn2) {\n      if (shade) {\n        return (\n          <Parametric\n            fn={x => [x, fn(x)]}\n            shade={shade}\n            range={range}\n            fn2={x => [x, fn2(x)]}\n            style={style}\n          />\n        )\n      } else {\n        throw new Error(\"fn2 should only be set when 'shade' is True.\")\n      }\n    }\n    return (\n      <Parametric\n        fn={x => [x, fn(x)]}\n        range={range}\n        shade={shade}\n        style={style}\n      />\n    )\n  }\n}\n","import React from \"react\"\nimport { useGraphie } from \"../graphie-context\"\nimport { Plot } from \"./plot\"\n\ntype propTypes = {\n  a?: number\n  b?: number\n  h?: number\n  k?: number\n  range?: []\n  style?: {}\n}\nexport const Exponential = ({\n  a = 1,\n  b = Math.E,\n  h = 0,\n  k = 0,\n  range,\n  style,\n}: propTypes) => {\n  const {\n    range: [xrange],\n  } = useGraphie()\n\n  const fn = (x: number) => a * b ** (x - h) + k\n  return (\n    <Plot\n      fn={fn}\n      range={range ? range : xrange}\n      swapAxes={false}\n      shade={false}\n      style={style}\n    />\n  )\n}\n","/**\n * Color constants we use throughout Perseus (originally on KhanUtil).\n *\n * Note that if the color palette changes substantially, it may also need to be\n * updated in khan-exercises and cherry-picked into graphie-to-png's\n * khan-exercises submodule, as graphie-to-png still relies on the palette\n * provided on KhanUtil.\n */\nconst KhanColors = {\n  BLUE: \"#6495ED\",\n  ORANGE: \"#FFA500\",\n  PINK: \"#FF00AF\",\n  GREEN: \"#28AE7B\",\n  PURPLE: \"#9D38BD\",\n  RED: \"#DF0030\",\n  GRAY: \"gray\",\n  BLACK: \"black\",\n  LIGHT_BLUE: \"#9AB8ED\",\n  LIGHT_ORANGE: \"#EDD19B\",\n  LIGHT_PINK: \"#ED9BD3\",\n  LIGHT_GREEN: \"#9BEDCE\",\n  LIGHT_PURPLE: \"#DA9BED\",\n  LIGHT_RED: \"#ED9AAC\",\n  LIGHT_GRAY: \"#ED9B9B\",\n  LIGHT_BLACK: \"#ED9B9B\",\n  GRAY10: \"#D6D6D6\",\n  GRAY20: \"#CDCDCD\",\n  GRAY30: \"#B3B3B3\",\n  GRAY40: \"#9A9A9A\",\n  GRAY50: \"#808080\",\n  GRAY60: \"#666666\",\n  GRAY70: \"#4D4D4D\",\n  GRAY80: \"#333333\",\n  GRAY90: \"#1A1A1A\",\n  BLUE_A: \"#CCFAFF\",\n  BLUE_B: \"#80F6FF\",\n  BLUE_C: \"#63D9EA\",\n  BLUE_D: \"#11ACCD\",\n  BLUE_E: \"#0C7F99\",\n  TEAL_A: \"#94FFF5\",\n  TEAL_B: \"#26EDD5\",\n  TEAL_C: \"#01D1C1\",\n  TEAL_D: \"#01A995\",\n  TEAL_E: \"#208170\",\n  GREEN_A: \"#B6FFB0\",\n  GREEN_B: \"#8AF281\",\n  GREEN_C: \"#74CF70\",\n  GREEN_D: \"#1FAB54\",\n  GREEN_E: \"#0D923F\",\n  GOLD_A: \"#FFD0A9\",\n  GOLD_B: \"#FFBB71\",\n  GOLD_C: \"#FF9C39\",\n  GOLD_D: \"#E07D10\",\n  GOLD_E: \"#A75A05\",\n  RED_A: \"#FCA9A9\",\n  RED_B: \"#FF8482\",\n  RED_C: \"#F9685D\",\n  RED_D: \"#E84D39\",\n  RED_E: \"#BC2612\",\n  MAROON_A: \"#FFBDE0\",\n  MAROON_B: \"#FF92C6\",\n  MAROON_C: \"#ED5FA6\",\n  MAROON_D: \"#CA337C\",\n  MAROON_E: \"#9E034E\",\n  PURPLE_A: \"#DDD7FF\",\n  PURPLE_B: \"#C6B9FC\",\n  PURPLE_C: \"#AA87FF\",\n  PURPLE_D: \"#7854AB\",\n  PURPLE_E: \"#543B78\",\n  MINT_A: \"#F5F9E8\",\n  MINT_B: \"#EDF2DF\",\n  MINT_C: \"#E0E5CC\",\n  GRAY_A: \"#F6F7F7\",\n  GRAY_B: \"#F0F1F2\",\n  GRAY_C: \"#E3E5E6\",\n  GRAY_D: \"#D6D8DA\",\n  GRAY_E: \"#BABEC2\",\n  GRAY_F: \"#888D93\",\n  GRAY_G: \"#626569\",\n  GRAY_H: \"#3B3E40\",\n  GRAY_I: \"#21242C\",\n  KA_BLUE: \"#314453\",\n  KA_GREEN: \"#71B307\",\n}\n\nKhanColors.INTERACTING = KhanColors.KA_GREEN\nKhanColors.INTERACTIVE = KhanColors.KA_GREEN\nKhanColors.DYNAMIC = KhanColors.BLUE\n\nexport default KhanColors\n","import React from \"react\"\n\nimport KhanColors from \"../util/colors\"\nimport { useGraphie } from \"../graphie-context\"\nimport { Line } from \"./primitives\"\n\ntype gridProps = { style?: {} }\nexport const Grid = ({ style }: gridProps) => {\n  const { range, gridStep, gridOpacity, isMobile } = useGraphie()\n  const grid = []\n\n  // horizontal grid\n  for (let x = Math.ceil(range[0][0]); x <= range[0][1]; x += gridStep[0]) {\n    grid.push(\n      <Line\n        key={`x-range-${x}`}\n        start={[x, range[1][1]]}\n        end={[x, range[1][0]]}\n      />\n    )\n  }\n\n  // vertical grid\n\n  for (let y = Math.ceil(range[1][0]); y <= range[1][1]; y += gridStep[1]) {\n    grid.push(\n      <Line\n        key={`y-range-${y}`}\n        start={[range[0][0], y]}\n        end={[range[0][1], y]}\n      />\n    )\n  }\n\n  let gridStyle = {\n    stroke: isMobile ? KhanColors.GRAY_C : \"#000000\",\n    opacity: isMobile ? 1 : gridOpacity,\n    strokeWidth: isMobile ? 1 : 2,\n    ...style,\n  }\n  return (\n    <g id=\"graphie-grid\" style={gridStyle}>\n      {grid}\n    </g>\n  )\n}\n","import { cleanMath } from \"./number-strings\"\nimport katex from \"katex\"\nimport \"katex/dist/katex.min.css\"\nimport \"katex/dist/fonts/KaTeX_Main-Regular.woff\"\nimport \"katex/dist/fonts/KaTeX_Main-Regular.woff\"\nimport \"katex/dist/fonts/KaTeX_Main-Regular.woff\"\n\nexport const processMath = function(text: string) {\n  // Attempt to clean up some of the math\n  text = cleanMath(text)\n  return katex.renderToString(String(text))\n}\n","import { number as knumber } from \"./math/index\"\n\n/**\n * Return a string of num rounded to a fixed precision decimal places,\n * with an approx symbol if num had to be rounded, and trailing 0s\n */\nexport function toFixedApprox(num: number, precision: number) {\n  const fixedStr = num.toFixed(precision)\n  if (knumber.equal(+fixedStr, num)) {\n    return fixedStr\n  } else {\n    return `\\\\approx ${fixedStr}`\n  }\n}\n\n/**\n * Return a string of num rounded to precision decimal places, with an\n * approx symbol if num had to be rounded, but no trailing 0s if it was\n * not rounded.\n */\nexport function roundToApprox(num: number, precision: number) {\n  const fixed = knumber.round(num, precision)\n  if (knumber.equal(fixed, num)) {\n    return String(fixed)\n  } else {\n    return toFixedApprox(num, precision)\n  }\n}\n\n// Returns the format (string) of a given numeric string\n// Note: purposively more inclusive than answer-types' predicate.forms\n// That is, it is not necessarily true that interpreted input are numeric\nexport function getNumericFormat(text: string) {\n  text = text.trim()\n  text = text.replace(/\\u2212/, \"-\").replace(/([+-])\\s+/g, \"$1\")\n  if (text.match(/^[+-]?\\d+$/)) {\n    return \"integer\"\n  } else if (text.match(/^[+-]?\\d+\\s+\\d+\\s*\\/\\s*\\d+$/)) {\n    return \"mixed\"\n  }\n  const fraction = text.match(/^[+-]?(\\d+)\\s*\\/\\s*(\\d+)$/)\n  if (fraction) {\n    return parseFloat(fraction[1]) > parseFloat(fraction[2])\n      ? \"improper\"\n      : \"proper\"\n  } else if (text.replace(/[,. ]/g, \"\").match(/^\\d+$/)) {\n    return \"decimal\"\n  } else if (text.match(/(pi?|\\u03c0|t(?:au)?|\\u03c4|pau)/)) {\n    return \"pi\"\n  } else {\n    return null\n  }\n}\n\n// Returns a string of the number in a specified format\nexport function toNumericString(number: number, format: string) {\n  if (number == null) {\n    return \"\"\n  } else if (number === 0) {\n    return \"0\" // otherwise it might end up as 0% or 0pi\n  }\n\n  if (format === \"percent\") {\n    return `${number * 100}%`\n  }\n\n  if (format === \"pi\") {\n    const fraction = knumber.toFraction(number / Math.PI)\n    const numerator = Math.abs(fraction[0])\n    const denominator = fraction[1]\n    if (Number.isInteger(numerator)) {\n      const sign = number < 0 ? \"-\" : \"\"\n      return `${sign}${numerator === 1 ? \"\" : numerator}Ï€${\n        denominator === 1 ? \"\" : `/${denominator}`\n      }`\n    }\n  }\n\n  if ([\"proper\", \"improper\", \"mixed\", \"fraction\"].includes(format)) {\n    const fraction = knumber.toFraction(number)\n    const numerator = Math.abs(fraction[0])\n    const denominator = fraction[1]\n    const sign = number < 0 ? \"-\" : \"\"\n    if (denominator === 1) {\n      return sign + numerator // for integers, irrational, d > 1000\n    } else if (format === \"mixed\") {\n      const modulus = numerator % denominator\n      const integer = (numerator - modulus) / denominator\n      return `${sign}${integer ? integer + \" \" : \"\"}${modulus}/${denominator}`\n    } // otherwise proper, improper, or fraction\n    return sign + numerator + \"/\" + denominator\n  }\n\n  // otherwise (decimal, float, long long)\n  return String(number)\n}\n\n// Simplify formulas before display\nexport function cleanMath(expr: string | any) {\n  return typeof expr === \"string\"\n    ? expr\n        .replace(/\\+\\s*-/g, \"- \")\n        .replace(/-\\s*-/g, \"+ \")\n        .replace(/\\^1/g, \"\")\n    : expr\n}\n","import * as React from \"react\"\n\nimport { processMath } from \"../util/tex\"\nimport KhanColors from \"../util/colors\"\nimport { scaleGridUnit, scaleAxisCenter, unscalePoint } from \"../util/svg-math\"\nimport { useGraphie } from \"../graphie-context\"\n\ntype labelProps = {\n  point: number[]\n  text: string\n  direction: string\n  latex?: boolean\n  style?: {}\n}\nexport const Label = ({\n  point,\n  text,\n  direction,\n  latex = true,\n  style,\n}: labelProps) => {\n  const { range, scale, tickLen } = useGraphie()\n  const [xUnit, yUnit] = scaleGridUnit(range, scale)\n\n  let _text = latex ? processMath(text) : text\n\n  const labelDirections: any = {\n    center: [-0.5, -0.5],\n    above: [-0.5, -1.0],\n    \"above right\": [0.0, -1.0],\n    right: [0.0, -0.5],\n    \"below right\": [0.0, 0.0],\n    below: [-0.5, tickLen[0] / 4],\n    \"below left\": [-1.0, 0.0],\n    left: [-1.0, -0.5],\n    \"above left\": [-1.0, -1.0],\n  }\n\n  const multipliers = labelDirections[direction]\n\n  const x = point[0] + xUnit * multipliers[0]\n  const y = point[1] + yUnit * multipliers[1]\n  const fontSize = `${(2.2 * scale[1]) / 500}ch`\n\n  return (\n    <foreignObject\n      className=\"graphie-label\"\n      x={x}\n      y={y}\n      width={xUnit}\n      height={yUnit}\n      style={{\n        textAlign: \"center\",\n        overflow: \"visible\",\n        pointerEvents: \"none\",\n      }}\n    >\n      <span\n        dangerouslySetInnerHTML={{ __html: _text }}\n        style={{ fontSize, userSelect: \"none\" }}\n      />\n    </foreignObject>\n  )\n}\n\nexport const Labels = () => {\n  const {\n    scale,\n    gridStep,\n    tickStep,\n    labelStep,\n    range,\n    axisLabels,\n    axisCenter,\n    axisArrows,\n    isMobile,\n    labelOpacity,\n    unityLabels,\n    xLabelFormat,\n    yLabelFormat,\n  } = useGraphie()\n  let style = {\n    stroke: isMobile ? KhanColors.GRAY_G : \"#000000\",\n    opacity: isMobile ? 1 : labelOpacity,\n  }\n  // Lets just set up some values to make the logic easier //\n\n  // how many pixels is one unit\n  const xUnit = scale[0] / (range[0][1] - range[0][0])\n  const yUnit = scale[1] / (range[1][1] - range[1][0])\n\n  // how many pixels should we jump to set the next label\n  const xStep = gridStep[0] * tickStep[0] * labelStep[0] * xUnit\n  const yStep = gridStep[1] * tickStep[1] * labelStep[1] * yUnit\n\n  // scale center from units to pixels\n  const [axisCenterX, axisCenterY] = scaleAxisCenter(axisCenter, range, scale)\n  // how should we render our labels if axis is off center\n  const xAxisPosition = axisCenter[0] < 0 ? \"above\" : \"below\"\n  const yAxisPosition = axisCenter[0] < 0 ? \"right\" : \"left\"\n  const xShowZero = axisCenter[0] === 0 && axisCenter[1] !== 0\n  const yShowZero = axisCenter[0] !== 0 && axisCenter[1] === 0\n  const axisOffCenter = axisCenter[0] !== 0 || axisCenter[1] !== 0\n  const showUnityX = unityLabels ? unityLabels[0] : axisOffCenter\n  const showUnityY = unityLabels ? unityLabels[1] : axisOffCenter\n\n  // if there are arrowheads on our axes, we don't want to place a label over it\n  const startArrow = [\"<->\", \"<-\", true].includes(axisArrows)\n  const endArrow = [\"<->\", \"->\", true].includes(axisArrows)\n\n  // minus sign moves text just right of center of tickmark\n  const negativeShiftCorrection = (6 / 500) * scale[0]\n\n  // store our labels here to render later\n  const labels = []\n\n  // positive x-axis\n  for (\n    let x = (xShowZero ? 0 : xStep) + axisCenterX;\n    x <= scale[0];\n    x += xStep\n  ) {\n    if (x < scale[0] - 10 || !endArrow) {\n      let l = unscalePoint(x, range, scale)[0]\n      // arrowhead is 10px\n      labels.push(\n        <Label\n          key={`x-label-${x}`}\n          point={[x, axisCenterY]}\n          text={xLabelFormat(l)}\n          direction={xAxisPosition}\n          style={style}\n        />\n      )\n    }\n  }\n\n  // negative x-axis\n  for (\n    let x = -xStep * (showUnityX ? 1 : 2) + axisCenterX;\n    x >= 0;\n    x -= xStep\n  ) {\n    if (x > 10 || !startArrow) {\n      let l = unscalePoint(x, range, scale)[0]\n      // arrowhead is 10px\n      labels.push(\n        <Label\n          key={`x-label-${x}`}\n          point={[x - negativeShiftCorrection, axisCenterY]}\n          text={xLabelFormat(l)}\n          direction={xAxisPosition}\n          style={style}\n        />\n      )\n    }\n  }\n\n  // positive y-axis\n  for (let y = axisCenterY - (yShowZero ? 0 : yStep); y >= 0; y -= yStep) {\n    if (y > 10 || !endArrow) {\n      let l = unscalePoint(y, range, scale)[1]\n      // arrowhead is 10px\n      labels.push(\n        <Label\n          key={`y-label-${y}`}\n          point={[axisCenterX, y]}\n          text={yLabelFormat(l)}\n          direction={yAxisPosition}\n          style={style}\n        />\n      )\n    }\n  }\n\n  // negative y-axis\n  for (\n    let y = yStep * (showUnityY ? 1 : 2) + axisCenterY;\n    y <= scale[1];\n    y += yStep\n  ) {\n    if (y < scale[1] - 10 || !startArrow) {\n      let l = unscalePoint(y, range, scale)[1]\n      // arrowhead is 10px\n      labels.push(\n        <Label\n          key={`y-label-${y}`}\n          point={[axisCenterX - negativeShiftCorrection, y]}\n          text={yLabelFormat(l)}\n          direction={yAxisPosition}\n          style={style}\n        />\n      )\n    }\n  }\n\n  if (axisLabels.length === 2) {\n    labels.push(\n      //[gridRange[0][1], axisCenter[1]], axisLabels[0], \"right\"\n      <Label\n        key={`x-axis-label`}\n        point={[scale[0], axisCenterY]}\n        text={axisLabels[0]}\n        direction=\"right\"\n        style={style}\n      />\n    )\n    labels.push(\n      <Label\n        key={`y-axis-label`}\n        point={[axisCenterX, 0]}\n        text={axisLabels[1]}\n        direction={\"above\"}\n        style={style}\n      />\n      //[axisCenter[0], gridRange[1][1]], axisLabels[1], \"above\"\n    )\n  }\n  return <g id=\"graphie-labels\">{labels}</g>\n}\n\n// TYPES //\ntype labelDirections = {\n  center: number[]\n  above: number[]\n  \"above right\": number[]\n  right: number[]\n  \"below right\": number[]\n  below: number[]\n  \"below left\": number[]\n  left: number[]\n  \"above left\": number[]\n}\n","import React from \"react\"\nimport { useGraphie } from \"../graphie-context\"\nimport { Plot } from \"./plot\"\n\ntype propTypes = {\n  a?: number\n  b?: number\n  h?: number\n  k?: number\n  range?: number[]\n  style?: {}\n}\nexport const Logarithmic = ({\n  a = 1,\n  b = 10,\n  h = 0,\n  k = 0,\n  range,\n  style,\n}: propTypes) => {\n  const {\n    range: [xrange],\n  } = useGraphie()\n  let log\n  if (b === 10) {\n    log = Math.log10\n  } else if (b === Math.E) {\n    log = Math.log\n  } else {\n    log = (x: number) => Math.log(x) / Math.log(b)\n  }\n\n  const fn = (x: number) => (x > h ? a * log(x - h) + k : a * log(h - x) + k)\n  const _range = range ? range : h < xrange[1] ? [h, xrange[1]] : null\n\n  if (!_range) return null\n\n  return (\n    <Plot fn={fn} range={_range} swapAxes={false} shade={false} style={style} />\n  )\n}\n","import * as React from \"react\"\nimport { parabola } from \"../util/svg-math\"\nimport { useGraphie } from \"../graphie-context\"\n\ntype propTypes = {\n  a: number\n  b: number\n  c: number\n  style?: {}\n}\nexport const Parabola = ({ a, b, c, style }: propTypes) => {\n  const { scale, range } = useGraphie()\n  const path = parabola(a, b, c, range, scale)\n\n  let parabolaStyle = {\n    fill: \"none\",\n    strokeWidth: 3,\n    ...style,\n  }\n  return <path d={path} style={parabolaStyle} />\n}\n","import React from \"react\"\nimport { useGraphie } from \"../graphie-context\"\nimport { Parametric } from \"./parametric\"\nimport { EndpointCircles } from \"./endpoint-circles\"\n\ntype propTypes = {\n  fnArray: Array<(x: number) => number>\n  rangeArray?: number[][]\n  endpoints?: Array<\"none\" | \"open\" | \"closed\">[]\n  style?: { [key: string]: any }\n}\nexport const Piecewise = ({\n  fnArray,\n  rangeArray,\n  endpoints,\n  style = {},\n}: propTypes) => {\n  const {\n    range: [xrange],\n  } = useGraphie()\n\n  let endpointArray = []\n  const paths = fnArray.map((fn, i) => {\n    let _range = rangeArray ? rangeArray[i] : xrange\n\n    // let's see if we need to add endpoints to this function\n    if (endpoints) {\n      // just make sure that the arrays match up\n      if (endpoints.length !== rangeArray.length) {\n        throw TypeError(\n          \"the endpoints array and rangeArray must be the same length when providing either to the Piecewise component\"\n        )\n      }\n      // do we add an endpoint to the start of the function?\n      if (endpoints[i][0] !== \"none\") {\n        endpointArray.push({\n          point: [_range[0], fn(_range[0])],\n          open: endpoints[i][0] === \"open\",\n        })\n      }\n      // do we add an endpoint to the end of the function?\n      if (endpoints[i][1] !== \"none\") {\n        endpointArray.push({\n          point: [_range[1], fn(_range[1])],\n          open: endpoints[i][1] === \"open\",\n        })\n      }\n    }\n    return (\n      <Parametric key={`piecewise-${i}`} range={_range} fn={x => [x, fn(x)]} />\n    )\n  })\n\n  let _endpoints = endpointArray && (\n    <EndpointCircles\n      endpointArray={endpointArray}\n      style={{ fill: style.stroke, ...style }}\n    />\n  )\n  return (\n    <g style={style}>\n      {paths}\n      {_endpoints}\n    </g>\n  )\n}\n","import * as React from \"react\"\nimport { cartFromPolarRad } from \"../util/math/vector\"\nimport { Parametric } from \"./parametric\"\n\ntype propTypes = {\n  fn: (th: number) => number[]\n  style?: {}\n}\nexport const Polar = ({ fn, style }: propTypes) => {\n  return (\n    <Parametric\n      fn={theta => cartFromPolarRad(fn(theta), theta)}\n      style={style}\n    />\n  )\n}\n","import React from \"react\"\n\nimport { sinusoid } from \"../util/svg-math\"\nimport { useGraphie } from \"../graphie-context\"\n\ntype sinusoidProps = {\n  a: number //amplitude\n  b: number // 2pi/frequency\n  c: number // phase shift\n  d: number // offset\n  style?: {}\n}\nexport const Sinusoid = ({ a, b, c, d, style }: sinusoidProps) => {\n  const { range, scale, axisCenter } = useGraphie()\n  const _d = d + axisCenter[1]\n  const _c = c + axisCenter[0]\n  const path = React.useMemo(() => sinusoid(a, b, _c, _d, range, scale), [\n    a,\n    b,\n    _c,\n    _d,\n    range,\n    scale,\n  ])\n\n  const sinusoidStyle = {\n    fill: \"none\",\n    ...style,\n  }\n  return <path d={path} style={sinusoidStyle} />\n}\n","import React from \"react\"\n\nimport { Line } from \"./primitives\"\nimport KhanColors from \"../util/colors\"\nimport { useGraphie } from \"../graphie-context\"\n\ntype tickMarkProps = { style?: {} }\nexport const TickMarks = ({ style }: tickMarkProps) => {\n  const {\n    isMobile,\n    tickOpacity,\n    tickLen,\n    tickStep,\n    axisCenter,\n    gridStep,\n    range,\n    axisArrows,\n  } = useGraphie()\n  let tickStyle = {\n    stroke: isMobile ? KhanColors.GRAY_G : \"#000000\",\n    opacity: isMobile ? 1 : tickOpacity,\n    strokeWidth: 1,\n    ...style,\n  }\n\n  // set up some basic mesuarements\n  const xLen = tickLen[0] / 2\n  const xStep = gridStep[0] * tickStep[0]\n  const yLen = tickLen[1] / 2\n  const yStep = gridStep[1] * tickStep[1]\n\n  const startArrow = [\"<->\", \"<-\", true].includes(axisArrows)\n  const endArrow = [\"<->\", \"->\", true].includes(axisArrows)\n  const [axisCenterX, axisCenterY] = axisCenter\n  const ticks = []\n\n  // horizontal ticks\n  for (let x = xStep + axisCenterX; x <= range[0][1]; x += xStep) {\n    if (x < range[0][1] - 1 / 3 || !endArrow) {\n      // arrowhead is 1/3 unit\n      ticks.push(\n        <Line\n          key={`x-tick-mark-${x}`}\n          start={[x, -xLen + axisCenterY]}\n          end={[x, xLen + axisCenterY]}\n          style={tickStyle}\n        />\n      )\n    }\n  }\n\n  for (let x = -xStep + axisCenterX; x >= range[0][0]; x -= xStep) {\n    if (x > range[0][0] + 1 / 3 || !startArrow) {\n      // arrowhead is 1/3 unit\n      ticks.push(\n        <Line\n          key={`x-tick-mark-${x}`}\n          start={[x, -xLen + axisCenterY]}\n          end={[x, xLen + axisCenterY]}\n          style={tickStyle}\n        />\n      )\n    }\n  }\n\n  // vertical axis\n\n  for (let y = yStep + axisCenterY; y <= range[1][1]; y += yStep) {\n    if (y < range[1][1] - 1 / 3 || !endArrow) {\n      // arrowhead is 1/3 unit\n      ticks.push(\n        <Line\n          key={`y-tick-mark-${y}`}\n          start={[-yLen + axisCenterX, y]}\n          end={[yLen + axisCenterX, y]}\n          style={tickStyle}\n        />\n      )\n    }\n  }\n\n  for (let y = -yStep + axisCenterY; y >= range[1][0]; y -= yStep) {\n    if (y > range[1][0] + 1 / 3 || !startArrow) {\n      // arrowhead is 1/3 unit\n      ticks.push(\n        <Line\n          key={`y-tick-mark-${y}`}\n          start={[-yLen + axisCenterX, y]}\n          end={[yLen + axisCenterX, y]}\n          style={tickStyle}\n        />\n      )\n    }\n  }\n\n  return <g id=\"graphie-tick-marks\">{ticks}</g>\n}\n","import React from \"react\"\nimport { Grid, Axes, TickMarks, Labels } from \"./graph-components\"\nimport { scaleGridUnit, scaleAxisCenter } from \"./util/svg-math\"\nimport { processMath } from \"./util/tex\"\n\nconst defaultOptions = {\n  range: [\n    [-10, 10],\n    [-10, 10],\n  ],\n  scale: [500, 500],\n  grid: true,\n  gridOpacity: 0.1,\n  gridStep: [1, 1],\n  axes: true,\n  axisCenter: [0, 0],\n  axisOpacity: 1.0,\n  axisLabels: [],\n  tickMarks: true,\n  tickStep: [2, 2],\n  tickLen: [0.5, 0.5],\n  tickOpacity: 1.0,\n  labelStep: [1, 1],\n  yLabelFormat: y => y,\n  xLabelFormat: x => x,\n  snap: [0.5, 0.5], // used to determine coordinate round to\n  isDragging: false, // Consumed by movables to decide when to update\n  setIsDragging: x => x, // Consumed by movables to begin a movable event\n  mouseMove: null, // Consumed by movables, usually to get the position\n  setMouseMove: x => null,\n}\nconst Context = React.createContext(defaultOptions)\n\ntype propTypes = {\n  options: {\n    range?: number[][] | number[] | number\n    scale?: number[] | number\n    grid?: boolean\n    gridOpacity?: number // (0 - 1)\n    gridStep?: number[] | number // relative to units\n    axes?: boolean\n    axisArrows?: string | boolean\n    axisOpacity?: number\n    axisCenter?: number[]\n    axisLabels?: string[]\n    tickMarks?: boolean\n    tickStep?: number[] | number // relative to grid steps\n    tickLen?: number[] | number // in pixels\n    tickOpacity?: number\n    labels?: boolean\n    labelStep?: number[] | number // relative to tickSteps\n    yLabelFormat?: (l: string | number) => string // fn to format label string for y-axis\n    xLabelFormat?: (l: string | number) => string // fn to formate label string for x-axis\n    smartLabelPositioning?: boolean // should ignore minus sign?\n  }\n  children: any\n}\n\nconst GraphieProvider = ({ options, children }: propTypes) => {\n  // some updates to props to allow for shorthanding ranges and the like\n  const cleanedOptions: any = Object.entries({\n    ...defaultOptions,\n    ...options,\n  }).reduce((acc, [prop, val]) => {\n    // for an option that does not be cleaned, make sure it gets to the acc\n    acc[prop] = val\n\n    if (\n      !prop.match(/.*Opacity$/) && // don't set gridOpacity\n      prop !== \"range\" &&\n      typeof val === \"number\"\n    ) {\n      acc[prop] = [val, val]\n    }\n\n    // allow symmetric ranges to be specified by the absolute values\n    if (prop === \"range\" || prop === \"gridRange\") {\n      if (Array.isArray(val)) {\n        // but don't mandate symmetric ranges\n        if (!Array.isArray(val[0])) {\n          acc[prop] = [\n            [-val[0], val[0]],\n            [-val[1], val[1]],\n          ]\n        }\n      } else if (typeof val === \"number\") {\n        acc[prop] = [\n          [-val, val],\n          [-val, val],\n        ]\n      }\n    }\n    return acc\n  }, {})\n\n  // set up axis labels\n  const {\n    scale,\n    grid,\n    axes,\n    tickMarks,\n    labels,\n    range,\n    axisCenter,\n    axisLabels,\n  } = cleanedOptions\n  let axisCenterX: number, axisCenterY: number\n  let xUnit: number, yUnit: number\n  let rangeShift: number, domainShift: number\n  let domainLabel = \"\"\n  let rangeLabel = \"\"\n  if (axisLabels.length === 2) {\n    let gridUnits = scaleGridUnit(range, scale)\n    xUnit = gridUnits[0]\n    yUnit = gridUnits[1]\n    let center = scaleAxisCenter(axisCenter, range, scale)\n    axisCenterX = center[0]\n    axisCenterY = center[1]\n    domainLabel = processMath(axisLabels[0])\n    rangeLabel = processMath(axisLabels[1])\n    domainShift = axisCenterX - yUnit / 2\n    rangeShift = axisCenterY - xUnit / 2\n  }\n\n  // mouse functions for movable components to consume\n  let [isDragging, setIsDragging] = React.useState(false)\n  let [mouseMove, setMouseMove] = React.useState(null)\n\n  const onMouseMove = (e: React.MouseEvent) => {\n    if (isDragging) {\n      e.persist()\n      setMouseMove(e)\n    }\n  }\n\n  const onMouseUp = () => {\n    setIsDragging(false)\n    setMouseMove(null)\n  }\n  return (\n    <Context.Provider\n      value={{\n        ...cleanedOptions,\n        isDragging,\n        setIsDragging,\n        mouseMove,\n        setMouseMove,\n      }}\n    >\n      <div>\n        <div\n          style={{\n            width: scale[0],\n            marginLeft: rangeShift,\n            padding: \"5px 0\",\n            userSelect: \"none\",\n          }}\n          dangerouslySetInnerHTML={{ __html: rangeLabel }}\n        />\n        <div style={{ display: \"flex\" }}>\n          <svg\n            xmlns=\"http://www.w3.org/2000/svg\"\n            version=\"1.1\"\n            width={scale[0]}\n            height={scale[1]}\n            className=\"graphie\"\n            style={{\n              cursor: isDragging ? \"move\" : \"inherit\",\n            }}\n            onMouseMove={onMouseMove}\n            onMouseUp={onMouseUp}\n            onMouseLeave={onMouseUp}\n          >\n            {grid && <Grid />}\n            {axes && <Axes />}\n            {tickMarks && <TickMarks />}\n            {labels && <Labels />}\n            {children}\n          </svg>\n          <div\n            style={{\n              marginTop: domainShift,\n              padding: \"0 5px\",\n              userSelect: \"none\",\n            }}\n            dangerouslySetInnerHTML={{ __html: domainLabel }}\n          />\n        </div>\n      </div>\n    </Context.Provider>\n  )\n}\n\ntype graphieType = {\n  range: number[][]\n  scale: number[]\n  grid: boolean\n  gridOpacity: number // (0 - 1)\n  gridStep: number[] // relative to units\n  axes: boolean\n  axisArrows?: string | boolean\n  axisOpacity?: number\n  axisCenter: number[]\n  axisLabels?: string[]\n  tickMarks?: boolean\n  tickStep: number[] // relative to grid steps\n  tickLen: number[] // in pixels\n  tickOpacity?: number\n  labels?: boolean\n  labelStep: number[] // relative to tickSteps\n  labelOpacity?: number\n  unityLabels?: boolean[] // include -1 on labels\n  yLabelFormat?: (l: string | number) => string // fn to format label string for y-axis\n  xLabelFormat?: (l: string | number) => string // fn to formate label string for x-axis\n  smartLabelPositioning?: boolean // should ignore minus sign?\n  isMobile?: boolean\n  isDragging: boolean // Consumed by movables to decide when to update\n  snap: number[]\n  setIsDragging: (x: boolean) => any // Consumed by movables to begin a movable event\n  mouseMove: React.MouseEvent // Consumed by movables, usually to get the position\n  setMouseMove: (x: React.MouseEvent | null) => null // Consumed by movable to reset mousemove\n}\nconst useGraphie = () => {\n  const graphie: graphieType = React.useContext(Context)\n\n  if (graphie === undefined) {\n    throw Error(\"useGraphie must be used in a GraphieProvider\")\n  }\n  return graphie\n}\n\nexport { GraphieProvider, useGraphie }\n","import React from \"react\"\nimport { unscalePoint, scalePoint, snapCoord } from \"../util/svg-math\"\nimport { useGraphie } from \"../graphie-context\"\nimport KhanColors from \"../util/colors\"\n\ntype propType = {\n  point: number[]\n  setPoint: (p: number[]) => any\n  snap?: number[]\n  style?: any\n}\nexport const MovablePoint = ({ point, setPoint, snap, style }: propType) => {\n  const {\n    range,\n    scale,\n    axisCenter,\n    isDragging,\n    setIsDragging,\n    mouseMove,\n    snap: defaultSnap,\n  } = useGraphie()\n\n  let ref = React.useRef()\n\n  React.useEffect(() => {\n    if (isDragging === ref.current && mouseMove) {\n      let { offsetX, offsetY } = mouseMove.nativeEvent\n      let _point = unscalePoint([offsetX, offsetY], range, scale)\n\n      setPoint(snapCoord(_point, snap ? snap : defaultSnap))\n    }\n  }, [isDragging, mouseMove])\n\n  const onMouseDown = () => setIsDragging(ref.current)\n\n  let _center = point.map((c, i) => c + axisCenter[i])\n  let scaledCenter = scalePoint(_center, range, scale)\n  let scaledRadius = (0.25 * scale[0]) / (range[0][1] - range[0][0])\n\n  let circleStyle = {\n    fill: KhanColors.PINK,\n    stroke: \"transparent\",\n    strokeWidth: 5,\n    cursor: \"move\",\n    ...style,\n  }\n  return (\n    <circle\n      ref={ref}\n      onMouseDown={onMouseDown}\n      cx={scaledCenter[0]}\n      cy={scaledCenter[1]}\n      r={scaledRadius}\n      style={circleStyle}\n    />\n  )\n}\n","import * as React from \"react\"\nimport { MovablePoint } from \"./movable-point\"\nimport KhanColors from \"../util/colors\"\nimport { slope } from \"../util/math/line\"\nimport { useGraphie } from \"../graphie-context\"\nimport { Line } from \"../graph-components\"\n\ntype propTypes = {\n  vertex: number[]\n  point: number[]\n  setVertex: (p: number[]) => any\n  setPoint: (p: number[]) => any\n  style?: {}\n}\nexport const MovableAbsoluteValue = ({\n  vertex,\n  point,\n  setVertex,\n  setPoint,\n  style,\n}: propTypes) => {\n  const {\n    range: [xrange],\n  } = useGraphie()\n  const m = Math.abs(slope([vertex, point]))\n\n  const y = (x: number) =>\n    vertex[1] < point[1]\n      ? m * Math.abs(x - vertex[0]) + vertex[1]\n      : -m * Math.abs(x - vertex[0]) + vertex[1]\n\n  const left = [xrange[0], y(xrange[0])]\n  const right = [xrange[1], y(xrange[1])]\n\n  // set up some extra constraints to ensure that we don't get a vertical line\n  const _setVertex = (p: number[]) => (p[0] === point[0] ? null : setVertex(p))\n  const _setPoint = (p: number[]) => (p[0] === vertex[0] ? null : setPoint(p))\n\n  let absoluteValueStyle = {\n    stroke: KhanColors.BLUE,\n    ...style,\n  }\n  return (\n    <g style={absoluteValueStyle}>\n      <Line start={left} end={vertex} />\n      <Line start={vertex} end={right} />\n      <MovablePoint point={vertex} setPoint={_setVertex} />\n      <MovablePoint point={point} setPoint={_setPoint} />\n    </g>\n  )\n}\n","import * as React from \"react\"\nimport KhanColors from \"../util/colors\"\nimport { useGraphie } from \"../graphie-context\"\nimport { unscalePoint, scalePoint, snapCoord } from \"../util/svg-math\"\n\ntype propTypes = {\n  axis: number\n  setAxis: (a: number) => any\n  snap?: number[]\n  vertical?: boolean\n  style?: {}\n}\nexport const MovableAsymptote = ({\n  axis,\n  setAxis,\n  snap,\n  vertical = false,\n  style,\n}: propTypes) => {\n  const {\n    range,\n    scale,\n    isDragging,\n    setIsDragging,\n    mouseMove,\n    snap: graphSnap,\n  } = useGraphie()\n\n  let ref = React.useRef()\n\n  React.useEffect(() => {\n    if (isDragging === ref.current && mouseMove) {\n      let { offsetX, offsetY } = mouseMove.nativeEvent\n\n      let point = unscalePoint([offsetX, offsetY], range, scale)\n      let [x, y] = snapCoord(point, snap ? snap : graphSnap)\n      setAxis(vertical ? x : y)\n    }\n  }, [isDragging, mouseMove, graphSnap, range, scale, setAxis, snap, vertical])\n\n  const onMouseDown = () => setIsDragging(ref.current)\n  let start = vertical ? [axis, range[1][0]] : [range[0][0], axis]\n  let end = vertical ? [axis, range[1][1]] : [range[0][1], axis]\n\n  let [x1, y1] = scalePoint(start, range, scale)\n  let [x2, y2] = scalePoint(end, range, scale)\n\n  let asymptoteStyle = {\n    stroke: KhanColors.PINK,\n    strokeWidth: 3,\n    cursor: \"move\",\n    ...style,\n  }\n  return (\n    <line\n      onMouseDown={onMouseDown}\n      ref={ref}\n      x1={x1}\n      x2={x2}\n      y1={y1}\n      y2={y2}\n      style={asymptoteStyle}\n    />\n  )\n}\n","import React from \"react\"\nimport { MovablePoint } from \"./movable-point\"\nimport { Circle } from \"../graph-components\"\nimport KhanColors from \"../util/colors\"\n\nexport const MovableCircle = ({ radius, setRadius, center, setCenter }) => {\n  const [draggableRadius, setDraggableRadius] = React.useState([\n    radius,\n    center[1],\n  ])\n\n  const updateDraggableRadius = (p: number[]) => {\n    let vector = [p[0] - center[0], p[1] - center[1]]\n    setRadius(Math.sqrt(vector[0] * vector[0] + vector[1] * vector[1]))\n    setDraggableRadius(p)\n  }\n\n  const updateDraggableCenter = (p: number[]) => {\n    let _draggableRadius = [\n      draggableRadius[0] - center[0] + p[0],\n      draggableRadius[1] - center[1] + p[1],\n    ]\n    setDraggableRadius(_draggableRadius)\n    setCenter(p)\n  }\n\n  return (\n    <>\n      <Circle\n        center={center}\n        radius={radius}\n        style={{ stroke: KhanColors.BLUE }}\n      />\n      <MovablePoint point={draggableRadius} setPoint={updateDraggableRadius} />\n      <MovablePoint point={center} setPoint={updateDraggableCenter} />\n    </>\n  )\n}\n","import React from \"react\"\nimport { MovablePoint } from \"./movable-point\"\nimport { MovableAsymptote } from \"./movable-asymptote\"\nimport KhanColors from \"../util/colors\"\nimport { Exponential } from \"../graph-components\"\n\ntype propTypes = {\n  axis: number\n  point1: number[]\n  point2: number[]\n  setAxis: (x: number) => any\n  setPoint1: (p: number[]) => any\n  setPoint2: (p: number[]) => any\n  style?: {}\n}\nexport const MovableExponential = ({\n  axis,\n  point1,\n  point2,\n  setAxis,\n  setPoint1,\n  setPoint2,\n  style,\n}: propTypes) => {\n  let k = axis\n  let b = Math.log((point1[1] - k) / (point2[1] - k)) / (point1[0] - point2[0])\n  let a = (point1[1] - k) / Math.exp(b * point1[0])\n\n  let exponentialStyle = {\n    stroke: KhanColors.BLUE,\n    strokeWidth: 3,\n    ...style,\n  }\n\n  const _setAxis = (x: number) => {\n    // restrict asymptote to only move up to the closes point\n\n    if (\n      /* eslint-disable no-mixed-operators */\n      k < point1[1] === k < point2[1] &&\n      x < point1[1] === x < point2[1] &&\n      x !== point1[1] &&\n      x !== point2[1]\n      /* eslint-enable no-mixed-operators */\n    ) {\n      // both points are on the same side of the asymptote\n      return setAxis(x)\n    }\n    return null\n  }\n\n  // we want to make sure that both points are above or below the asymptote.\n  // So if we move a point across the asymptote we need to reflect the other one\n  const _setPoint1 = (p: number[]) => {\n    // cannot have the same x value\n    if (p[0] === point2[0]) return null\n\n    // eslint-disable-next-line no-mixed-operators\n    if (p[1] < k !== point2[1] < k) {\n      // point has crossed the asymptote so reflect the other\n      setPoint1(p)\n      setPoint2([point2[0], -point2[1]])\n    } else {\n      setPoint1(p)\n    }\n  }\n\n  // make sure we reflect the point the same across the asymptote\n  const _setPoint2 = (p: number[]) => {\n    // cannot have the same x value\n    if (p[0] === point1[0]) return null\n\n    // eslint-disable-next-line no-mixed-operators\n    if (p[1] < k !== point1[1] < k) {\n      // point has crossed the asymptote so reflect the other\n      setPoint2(p)\n      setPoint1([point1[0], -point1[1]])\n    } else {\n      setPoint2(p)\n    }\n  }\n\n  return (\n    <g style={exponentialStyle}>\n      <Exponential a={a} b={Math.exp(b)} k={k} />\n      <MovableAsymptote axis={k} setAxis={_setAxis} />\n      <MovablePoint point={point1} setPoint={_setPoint1} />\n      <MovablePoint point={point2} setPoint={_setPoint2} />\n    </g>\n  )\n}\n","import React from \"react\"\nimport { MovablePoint } from \"./movable-point\"\nimport { Line } from \"../graph-components\"\nimport { getSlopeIntercept } from \"../util/math/line\"\nimport { useGraphie } from \"../graphie-context\"\n\ntype segmentTypes = {\n  point1: number[]\n  point2: number[]\n  setPoint1: (p: number[]) => void\n  setPoint2: (p: number[]) => void\n  style?: {}\n}\nexport const MovableLineSegment = ({\n  point1,\n  point2,\n  setPoint1,\n  setPoint2,\n  style,\n}: segmentTypes) => {\n  return (\n    <g style={style}>\n      <Line start={point1} end={point2} />\n      <MovablePoint point={point1} setPoint={setPoint1} />\n      <MovablePoint point={point2} setPoint={setPoint2} />\n    </g>\n  )\n}\n\ntype rayTypes = {\n  point1: number[]\n  point2: number[]\n  setPoint1: (p: number[]) => void\n  setPoint2: (p: number[]) => void\n  style?: {}\n}\nexport const MovableLineRay = ({\n  point1,\n  point2,\n  setPoint1,\n  setPoint2,\n  style,\n}) => {\n  const {\n    range: [xrange, yrange],\n  } = useGraphie()\n  // need to extend the line beyond the view, so points have to be modified to be\n  // collinear and far away.\n  let [m, b] = getSlopeIntercept([point1, point2])\n\n  const y = x => m * x + b\n  let end, ycoord\n  if (point1[0] <= point2[0]) {\n    if (Math.abs(m) === Infinity) {\n      ycoord = point2[1] < point1[1] ? yrange[0] : yrange[1]\n      end = [point2[0], ycoord]\n    } else {\n      end = [xrange[1], y(xrange[1])]\n    }\n  } else {\n    end = [xrange[0], y(xrange[0])]\n  }\n\n  return (\n    <g style={style}>\n      <Line start={point1} end={end} />\n      <MovablePoint point={point1} setPoint={setPoint1} />\n      <MovablePoint point={point2} setPoint={setPoint2} />\n    </g>\n  )\n}\n\ntype lineTypes = {\n  point1: number[]\n  point2: number[]\n  setPoint1: (p: number[]) => void\n  setPoint2: (p: number[]) => void\n  style?: {}\n}\nexport const MovableLine = ({\n  point1,\n  point2,\n  setPoint1,\n  setPoint2,\n  style,\n}: lineTypes) => {\n  const {\n    range: [xrange, yrange],\n  } = useGraphie()\n  // need to extend the line beyond the view, so points have to be modified to be\n  // collinear and far away.\n  let [m, b] = getSlopeIntercept([point1, point2])\n\n  const y = x => m * x + b\n\n  let [start, end] =\n    m === Infinity // return points for vertical line\n      ? [\n          [point1[0], yrange[0]],\n          [point1[0], yrange[1]],\n        ]\n      : [\n          [xrange[0], y(xrange[0])],\n          [xrange[1], y(xrange[1])],\n        ]\n\n  return (\n    <g style={style}>\n      <Line start={start} end={end} />\n      <MovablePoint point={point1} setPoint={setPoint1} />\n      <MovablePoint point={point2} setPoint={setPoint2} />\n    </g>\n  )\n}\n","import React from \"react\"\nimport { MovablePoint } from \"./movable-point\"\nimport { MovableAsymptote } from \"./movable-asymptote\"\nimport { Logarithmic } from \"../graph-components/logarithmic\"\nimport KhanColors from \"../util/colors\"\nimport { useGraphie } from \"../graphie-context\"\n\ntype propTypes = {\n  axis: number\n  point1: number[]\n  point2: number[]\n  setAxis: (x: number) => any\n  setPoint1: (p: number[]) => any\n  setPoint2: (p: number[]) => any\n  style?: {}\n}\nexport const MovableLogarithmic = ({\n  axis,\n  point1,\n  point2,\n  setAxis,\n  setPoint1,\n  setPoint2,\n  style,\n}: propTypes) => {\n  const {\n    range: [xrange],\n  } = useGraphie()\n  // it is easier to reason about these values in the exponential form\n  // y = a*exp(b*x) + k. Find the inverse function: y = 1/b*ln(x-k) - 1/b*ln(a),\n  // left as an exercise for the reader.\n  // Since exponetial is the inverse of logarithmic, we can just solve the\n  // inverse points to get a, b and find _a = 1/b, _b = e and _k = -1/b*ln(a)\n  let k = axis\n  let b = Math.log((point1[0] - k) / (point2[0] - k)) / (point1[1] - point2[1])\n  let a = (point1[0] - k) / Math.exp(b * point1[1])\n\n  let _a = 1 / b\n  let _b = Math.E\n  let _k = a > 0 ? (-1 / b) * Math.log(a) : -Math.log(-a) / b\n  let range = a > 0 ? [axis, xrange[1]] : [xrange[0], axis]\n\n  let logarithmicStyle = {\n    stroke: KhanColors.BLUE,\n    strokeWidth: 3,\n    ...style,\n  }\n\n  // modify set functions to constrain movement to mathematically logical positions\n  const _setAxis = (x: number) => {\n    // restrict asymptote to only move up to the closest point\n    if (\n      /* eslint-disable no-mixed-operators */\n      k < point1[0] === k < point2[0] &&\n      x < point1[0] === x < point2[0] &&\n      x !== point1[0] &&\n      x !== point2[0]\n      /* eslint-enable no-mixed-operators */\n    ) {\n      // both points are on the same side of the asymptote\n      return setAxis(x)\n    }\n    return null\n  }\n\n  // we want to make sure that both points are above or below the asymptote.\n  // So if we move a point across the asymptote we need to reflect the other one\n  const _setPoint1 = (p: number[]) => {\n    // cannot have the same x or y value\n    if (p[1] === point2[1] || p[0] === point2[0]) return null\n\n    // eslint-disable-next-line no-mixed-operators\n    if (p[0] < k !== point2[0] < k) {\n      // point has crossed the asymptote\n      setPoint1(p)\n      setPoint2([-point2[0], point2[1]])\n    } else {\n      setPoint1(p)\n    }\n  }\n\n  // make sure we reflect the point the same across the asymptote\n  const _setPoint2 = (p: number[]) => {\n    // cannot have the same x or y value\n    if (p[1] === point1[1] || p[0] === point1[0]) return null\n\n    // eslint-disable-next-line no-mixed-operators\n    if (p[0] < k !== point1[0] < k) {\n      // point has crossed the asymptote\n      setPoint2(p)\n      setPoint1([-point1[0], point1[1]])\n    } else {\n      setPoint2(p)\n    }\n  }\n\n  return (\n    <g style={logarithmicStyle}>\n      <Logarithmic a={_a} b={_b} h={k} k={_k} range={range} />\n      <MovableAsymptote axis={k} setAxis={_setAxis} vertical={true} />\n      <MovablePoint point={point1} setPoint={_setPoint1} />\n      <MovablePoint point={point2} setPoint={_setPoint2} />\n    </g>\n  )\n}\n","import React from \"react\"\nimport { MovablePoint } from \"./movable-point\"\nimport { Parabola } from \"../graph-components\"\n\ntype propTypes = {\n  vertex: number[]\n  point: number[]\n  setVertex: (p: number[]) => any\n  setPoint: (p: number[]) => any\n  style?: {}\n}\nexport const MovableParabola = ({\n  vertex,\n  point,\n  setVertex,\n  setPoint,\n  style,\n}: propTypes) => {\n  let a = (point[1] - vertex[1]) / (point[0] - vertex[0]) ** 2\n  let b = -2 * a * vertex[0]\n  let c = a * vertex[0] * vertex[0] + vertex[1]\n\n  return (\n    <g style={style}>\n      <Parabola a={a} b={b} c={c} />\n      <MovablePoint point={vertex} setPoint={setVertex} />\n      <MovablePoint point={point} setPoint={setPoint} />\n    </g>\n  )\n}\n","import React from \"react\"\nimport { MovablePoint } from \"./movable-point\"\nimport KhanColors from \"../util/colors\"\nimport { Sinusoid } from \"../graph-components\"\n\ntype propTypes = {\n  midpoint: number[]\n  maxpoint: number[]\n  setMidpoint: (p: number[]) => any\n  setMaxpoint: (p: number[]) => any\n  style?: {}\n}\nexport const MovableSinusoid = ({\n  midpoint,\n  maxpoint,\n  setMidpoint,\n  setMaxpoint,\n  style,\n}: propTypes) => {\n  let a = midpoint[1] - maxpoint[1]\n  let b = Math.PI / (2 * (midpoint[0] - maxpoint[0]))\n  let c = maxpoint[0] * b + Math.PI / 2\n  let d = midpoint[1]\n\n  let _setMidpoint = (p: number[]) =>\n    p[0] === maxpoint[0] ? null : setMidpoint(p)\n  let _setMaxpoint = (p: number[]) =>\n    p[0] === midpoint[0] ? null : setMaxpoint(p)\n\n  let sinusoidStyle = {\n    stroke: KhanColors.BLUE,\n    ...style,\n  }\n  return (\n    <g style={sinusoidStyle}>\n      <Sinusoid a={a} b={b} c={c} d={d} />\n      <MovablePoint point={midpoint} setPoint={_setMidpoint} />\n      <MovablePoint point={maxpoint} setPoint={_setMaxpoint} />\n    </g>\n  )\n}\n","import React from \"react\"\nimport { MovablePoint } from \"./movable-point\"\nimport KhanColors from \"../util/colors\"\nimport { Plot } from \"../graph-components\"\nimport { useGraphie } from \"../graphie-context\"\n\ntype propTypes = {\n  point1: number[]\n  point2: number[]\n  setPoint1: (p: number[]) => any\n  setPoint2: (p: number[]) => any\n  style?: {}\n}\nexport const MovableTangent = ({\n  point1,\n  point2,\n  setPoint1,\n  setPoint2,\n  style,\n}: propTypes) => {\n  const {\n    range: [xrange],\n  } = useGraphie()\n  let a = point2[1] - point1[1]\n  let b = Math.PI / (4 * (point2[0] - point1[0]))\n  let c = point1[0] * b\n  let d = point1[1]\n  let fn = (x: number) => a * Math.tan(b * x - c) + d\n\n  const _setPoint1 = (p: number[]) => (p[0] === point2[0] ? null : setPoint1(p))\n  const _setPoint2 = (p: number[]) => (p[0] === point1[0] ? null : setPoint2(p))\n\n  let tangentStyle = {\n    stroke: KhanColors.BLUE,\n    ...style,\n  }\n  return (\n    <g style={tangentStyle}>\n      <Plot fn={fn} shade={false} swapAxes={false} range={xrange} />\n      <MovablePoint point={point1} setPoint={_setPoint1} />\n      <MovablePoint point={point2} setPoint={_setPoint2} />\n    </g>\n  )\n}\n","import * as React from \"react\"\nimport * as ReactDOM from \"react-dom\"\n\nimport {\n  GraphieProvider,\n  useGraphie,\n  MovableAsymptote,\n  MovableCircle,\n  MovableExponential,\n  MovableLine,\n  MovableLineRay,\n  MovableLineSegment,\n  MovablePoint,\n  MovableParabola,\n  MovableSinusoid,\n  MovableTangent,\n  MovableLogarithmic,\n  MovableAbsoluteValue,\n  Arc,\n  Asymptotes,\n  Circle,\n  Ellipse,\n  EndpointCircles,\n  Exponential,\n  Line,\n  Logarithmic,\n  Parabola,\n  Parametric,\n  Path,\n  Piecewise,\n  Plot,\n  Polar,\n  Polygon,\n  Rect,\n  Sinusoid,\n  svgMath,\n} from \"../lib\"\n\nconst TestArc = () => (\n  <Arc\n    center={[1, 1]}\n    radius={5}\n    startAngle={0}\n    endAngle={(3 / 4) * Math.PI}\n    sector={false}\n    style={{\n      stroke: \"var(--graphie-LIGHT_RED)\",\n    }}\n  />\n)\n\nconst TestAsymptotes = () => (\n  <Asymptotes key=\"test-asymptote\" fn={x => (1 + 5 * x) / (x - 1)} />\n)\n\nconst TestCircle = () => (\n  <Circle\n    center={[-3, 5]}\n    radius={4}\n    style={{ stroke: \"var(--graphie-GREEN)\" }}\n  />\n)\n\nconst TestEllipse = () => (\n  <Ellipse\n    center={[5, -1]}\n    radii={[4, 2]}\n    style={{ stroke: \"var(--graphie-MAROON_C)\", strokeWidth: 3 }}\n  />\n)\n\nconst TestEndpointCircles = () => (\n  <EndpointCircles\n    endpointArray={[\n      { point: [-8, 8], open: false },\n      { point: [8, -8], open: true },\n    ]}\n    style={{ stroke: \"var(--graphie-TEAL_D)\", fill: \"var(--graphie-TEAL_D)\" }}\n  />\n)\n\nconst TestExponential = () => (\n  <Exponential\n    a={0.5}\n    b={Math.E}\n    h={-1}\n    k={3}\n    style={{ stroke: \"var(--graphie-TEAL_D)\" }}\n  />\n)\n\nconst TestLine = () => (\n  <Line\n    start={[-8, 8]}\n    end={[8, -8]}\n    style={{ stroke: \"var(--graphie-BLUE)\", strokeWidth: 3 }}\n  />\n)\n\nconst TestLogarithmic = () => (\n  <Logarithmic\n    a={1}\n    b={2}\n    h={-1}\n    k={3}\n    style={{ stroke: \"var(--graphie-TEAL_D)\" }}\n  />\n)\n\nconst TestParabola = () => (\n  <Parabola a={1} b={3} c={4} style={{ stroke: \"var(--graphie-RED_D)\" }} />\n)\n\nconst TestParametric = () => (\n  <Parametric\n    fn={x => [x, (1 + 5 * x) / (x - 1)]}\n    shade={true}\n    style={{\n      stroke: \"var(--graphie-PINK)\",\n      strokeWidth: 3,\n    }}\n  />\n)\n\nconst TestPath = () => {\n  const { range, scale } = useGraphie()\n  let points = [\n    [-9, 0],\n    [0, -9],\n    [9, 0],\n    [0, 9],\n  ].map(p => svgMath.scalePoint(p, range, scale).join())\n  let path = `M${points.join(\"L\")}z`\n  return (\n    <Path d={path} style={{ stroke: \"var(--graphie-MINT_C)\", fill: \"none\" }} />\n  )\n}\n\nconst TestPiecewise = () => (\n  <Piecewise\n    fnArray={[x => x / 3 - 4, t => 0.5 * t * t + 3]}\n    rangeArray={[\n      [-10, -1],\n      [-1, 10],\n    ]}\n    endpoints={[\n      [\"none\", \"open\"],\n      [\"closed\", \"none\"],\n    ]}\n    style={{ stroke: \"var(--graphie-PURPLE_D)\" }}\n  />\n)\n\nconst TestPlot = () => (\n  <Plot\n    fn={x => 3 * Math.E ** x}\n    range={[-10, 10]}\n    swapAxes={false}\n    shade={true}\n  />\n)\n\n// TODO: Not quite working\nconst TestPolar = () => (\n  <Polar\n    fn={Î˜ => [1 - Math.sin(Î˜), Î˜]}\n    style={{ stroke: \"var(--graphie-ORANGE)\" }}\n  />\n)\n\nconst TestPolygon = () => (\n  <Polygon\n    points={[\n      [0, 8],\n      [-8, 5],\n      [-4, -6],\n      [4, -6],\n      [8, 5],\n    ]}\n    style={{ fill: \"var(--graphie-KA_BLUE)\", opacity: 0.6 }}\n  />\n)\n\nconst TestRect = () => (\n  <Rect\n    x={-8}\n    y={4}\n    width={10}\n    height={12}\n    style={{\n      fill: \"var(--graphie-PURPLE_D)\",\n      stroke: \"var(--graphie-PURPLE_E)\",\n      strokeWidth: 5,\n    }}\n  />\n)\n\nconst TestSinusoid = () => (\n  <Sinusoid\n    a={3}\n    b={1}\n    c={-Math.PI / 2}\n    d={4}\n    style={{ stroke: \"var(--graphie-PURPLE)\" }}\n  />\n)\n\nconst TestMovableAbsoluteValue = () => {\n  let [vertex, setVertex] = React.useState([0, 0])\n  let [point, setPoint] = React.useState([5, 5])\n  return (\n    <MovableAbsoluteValue\n      vertex={vertex}\n      setVertex={setVertex}\n      point={point}\n      setPoint={setPoint}\n    />\n  )\n}\nconst TestMovablePoint = () => {\n  let [point, setPoint] = React.useState([5, 5])\n  return <MovablePoint point={point} setPoint={setPoint} />\n}\n\nconst TestMovableAsymptote = () => {\n  let [axis, setAxis] = React.useState(5)\n  return <MovableAsymptote axis={axis} setAxis={setAxis} vertical={true} />\n}\n\nconst TestMovableCircle = () => {\n  let [radius, setRadius] = React.useState(4)\n  let [center, setCenter] = React.useState([0, 0])\n  return (\n    <MovableCircle\n      center={center}\n      radius={radius}\n      setCenter={setCenter}\n      setRadius={setRadius}\n    />\n  )\n}\n\nconst TestMovableExponential = () => {\n  let [axis, setAxis] = React.useState(0)\n  let [point1, setPoint1] = React.useState([0, 2])\n  let [point2, setPoint2] = React.useState([2, 4])\n  return (\n    <MovableExponential\n      axis={axis}\n      point1={point1}\n      point2={point2}\n      setAxis={setAxis}\n      setPoint1={setPoint1}\n      setPoint2={setPoint2}\n    />\n  )\n}\nconst TestMovableLine = () => {\n  let [point1, setPoint1] = React.useState([-5, 5])\n  let [point2, setPoint2] = React.useState([5, -5])\n  return (\n    <MovableLine\n      point1={point1}\n      point2={point2}\n      setPoint1={setPoint1}\n      setPoint2={setPoint2}\n      style={{ stroke: \"var(--graphie-BLUE)\" }}\n    />\n  )\n}\nconst TestMovableLineRay = () => {\n  let [point1, setPoint1] = React.useState([-5, -5])\n  let [point2, setPoint2] = React.useState([5, 5])\n  return (\n    <MovableLineRay\n      point1={point1}\n      point2={point2}\n      setPoint1={setPoint1}\n      setPoint2={setPoint2}\n      style={{ stroke: \"var(--graphie-BLUE)\" }}\n    />\n  )\n}\n\nconst TestMovableLineSegment = () => {\n  let [point1, setPoint1] = React.useState([-5, 5])\n  let [point2, setPoint2] = React.useState([5, -5])\n  return (\n    <MovableLineSegment\n      point1={point1}\n      point2={point2}\n      setPoint1={setPoint1}\n      setPoint2={setPoint2}\n      style={{ stroke: \"var(--graphie-BLUE)\" }}\n    />\n  )\n}\n\nconst TestMovableLogarithmic = () => {\n  let [axis, setAxis] = React.useState(0)\n  let [point1, setPoint1] = React.useState([1, 0])\n  let [point2, setPoint2] = React.useState([4, 2])\n  return (\n    <MovableLogarithmic\n      axis={axis}\n      point1={point1}\n      point2={point2}\n      setAxis={setAxis}\n      setPoint1={setPoint1}\n      setPoint2={setPoint2}\n    />\n  )\n}\n\nconst TestMovableParabola = () => {\n  let [point, setPoint] = React.useState([5, 5])\n  let [vertex, setVertex] = React.useState([0, 0])\n  return (\n    <MovableParabola\n      point={point}\n      setPoint={setPoint}\n      vertex={vertex}\n      setVertex={setVertex}\n      style={{ stroke: \"var(--graphie-BLUE)\" }}\n    />\n  )\n}\n\nconst TestMovableSinusoid = () => {\n  let [maxpoint, setMaxpoint] = React.useState([3, 5])\n  let [midpoint, setMidpoint] = React.useState([0, 0])\n\n  return (\n    <MovableSinusoid\n      maxpoint={maxpoint}\n      midpoint={midpoint}\n      setMaxpoint={setMaxpoint}\n      setMidpoint={setMidpoint}\n      style={{ stroke: \"var(--graphie-BLUE)\" }}\n    />\n  )\n}\n\nconst TestMovableTangent = () => {\n  let [point1, setPoint1] = React.useState([3, 5])\n  let [point2, setPoint2] = React.useState([0, 0])\n\n  return (\n    <MovableTangent\n      point1={point1}\n      point2={point2}\n      setPoint1={setPoint1}\n      setPoint2={setPoint2}\n      style={{ stroke: \"var(--graphie-BLUE)\" }}\n    />\n  )\n}\n\nfunction App() {\n  const [shapes, setShapes] = React.useState<string[]>([])\n  const [movables, setMovables] = React.useState<string[]>([])\n\n  const options = {\n    axisArrows: \"<->\",\n    gridStep: 1,\n    isMobile: false,\n    xLabelFormat: (l: string | number) => `\\\\small{${l}}`,\n    yLabelFormat: (l: string | number) => `\\\\small{${l}}`,\n    // axisCenter: [-6, -8],\n    axes: true,\n    grid: true,\n    tickMarks: true,\n    tickStep: 1,\n    labelStep: 1,\n    labels: true,\n    axisLabels: [\"x\", \"f(x)\"],\n    range: [\n      [-10, 10],\n      [-10, 10],\n    ],\n    scale: [600, 600],\n  }\n\n  const availableShapes: { [key: string]: any } = {\n    arc: <TestArc key=\"test-arc\" />,\n    asymptotes: <TestAsymptotes key=\"test-asymptotes\" />,\n    circle: <TestCircle key=\"test-circle\" />,\n    ellipse: <TestEllipse key=\"test-ellipse\" />,\n    endpointCircles: <TestEndpointCircles key=\"test-endpoint-circles\" />,\n    exponential: <TestExponential key=\"test-exponential\" />,\n    line: <TestLine key=\"test-line\" />,\n    logarithmic: <TestLogarithmic key=\"test-logarithmic\" />,\n    parabola: <TestParabola key=\"test-parabola\" />,\n    parametric: <TestParametric key=\"test-parametric\" />,\n    path: <TestPath key=\"test-path\" />,\n    piecewise: <TestPiecewise key=\"test-piecewise\" />,\n    plot: <TestPlot key=\"test-plot\" />,\n    polar: <TestPolar key=\"test-polar\" />,\n    polygon: <TestPolygon key=\"test-polygon\" />,\n    rect: <TestRect key=\"test-rect\" />,\n    sinusoid: <TestSinusoid key=\"test-sinusoid\" />,\n  }\n\n  const availabeMovables: { [key: string]: any } = {\n    \"absolute value\": (\n      <TestMovableAbsoluteValue key=\"test-movable-absolute-value\" />\n    ),\n    asymptote: <TestMovableAsymptote key=\"test-movable-asymptote\" />,\n    point: <TestMovablePoint key=\"test-movable-point\" />,\n    circle: <TestMovableCircle key=\"test-movable-circle\" />,\n    exponential: <TestMovableExponential key=\"test-movable-exponential\" />,\n    line: <TestMovableLine key=\"test-movable-line\" />,\n    \"line ray\": <TestMovableLineRay key=\"test-movable-line ray\" />,\n    \"line segment\": <TestMovableLineSegment key=\"test-movable-line segment\" />,\n    logarithmic: <TestMovableLogarithmic key=\"test-movable-logarithmic\" />,\n    parabola: <TestMovableParabola key=\"test-movable-parabola\" />,\n    sinusoid: <TestMovableSinusoid key=\"test-movable-sinusoid\" />,\n    tangent: <TestMovableTangent key=\"test-movable-tangent\" />,\n  }\n\n  return (\n    <div\n      style={{\n        padding: 30,\n        position: \"relative\",\n        border: \"thin solid purple\",\n        display: \"flex\",\n      }}\n    >\n      <section>\n        <GraphieProvider options={options}>\n          {shapes.map(c => availableShapes[c])}\n          {movables.map(m => availabeMovables[m])}\n        </GraphieProvider>\n      </section>\n      <section>\n        <section>\n          <h2>Graph Shapes</h2>\n          <form>\n            {Object.keys(availableShapes).map(name => (\n              <div key={name}>\n                <label>\n                  <input\n                    type=\"checkbox\"\n                    checked={shapes.includes(name)}\n                    onChange={() =>\n                      shapes.includes(name)\n                        ? setShapes(shapes.filter(c => c !== name))\n                        : setShapes([...shapes, name])\n                    }\n                  />{\" \"}\n                  {name}\n                </label>\n              </div>\n            ))}\n          </form>\n        </section>\n        <section>\n          <h2>Graph Movables</h2>\n          <form>\n            {Object.keys(availabeMovables).map(name => (\n              <div key={name}>\n                <label>\n                  <input\n                    type=\"checkbox\"\n                    checked={movables.includes(name)}\n                    onChange={() =>\n                      movables.includes(name)\n                        ? setMovables(movables.filter(c => c !== name))\n                        : setMovables([...movables, name])\n                    }\n                  />{\" \"}\n                  {name}\n                </label>\n              </div>\n            ))}\n          </form>\n        </section>\n      </section>\n    </div>\n  )\n}\n\nconst rootElement = document.getElementById(\"root\")\nReactDOM.render(<App />, rootElement)\n"],"sourceRoot":""}